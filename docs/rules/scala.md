---
layout: default
title: Scala
parent: Rules
---

# Scala
{: .no_toc }


## Оглавление
{: .no_toc .text-delta }

1. TOC
{:toc}

---





## Раскрытие конфиденциальной информации

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
// Несоответствующий код - раскрытие конфиденциальной информации в журнале ошибок
def processUserInput(input: String): Unit = {
  // Обработка пользовательского ввода
  // ...
  
  // Ошибка в журнале с конфиденциальной информацией
  val errorMessage = s"Error processing user input: $input"
  Logger.error(errorMessage)
}
```

В этом примере кода, не соответствующем требованиям, функция processUserInput() регистрирует сообщение об ошибке, включающее пользовательский ввод, непосредственно в журнале ошибок с помощью регистратора. Это может привести к раскрытию конфиденциальной информации для всех, кто имеет доступ к файлу журнала ошибок, включая неавторизованных пользователей.





<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
// Соответствующий код - предотвращение попадания конфиденциальной информации в журнал ошибок
def processUserInput(input: String): Unit = {
  // Обработка пользовательского ввода
  // ...
  
  // Регистрация ошибок без конфиденциальной информации
  Logger.error("Error processing user input")
}
```


В примере кода, соответствующего требованиям, функция processUserInput() регистрирует общее сообщение об ошибке, не включая в него пользовательский ввод. Избегая включения конфиденциальной информации в журнал ошибок, код снижает риск раскрытия конфиденциальных данных неавторизованным лицам.

Важно отметить, что журнал ошибок должен содержать только информацию, необходимую для отладки, и не должен содержать конфиденциальных данных. Кроме того, рекомендуется соответствующим образом настроить параметры журнала ошибок и ограничить доступ к файлам журнала ошибок только для авторизованного персонала.


## Вставка конфиденциальной информации в отправленные данные

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
// Несоответствующий код - вставка конфиденциальной информации в отправленные данные
def sendUserData(userId: String): Unit = {
  // Получение пользовательских данных
  val userData = retrieveUserData(userId)
  
  // Вставка конфиденциальной информации в отправленные данные
  val sentData = s"User data: $userData"
  sendRequest(sentData)
}

def retrieveUserData(userId: String): String = {
  // Получение данных о пользователе из базы данных
  // ...
  // Возвращаем данные пользователя в виде строки
}

def sendRequest(data: String): Unit = {
  // Отправьте данные на удаленный сервер
  // ...
}
```

В этом примере кода, не соответствующем требованиям, функция sendUserData() получает данные пользователя и вставляет конфиденциальную информацию непосредственно в строку sentData. Затем строка sentData отправляется на удаленный сервер с помощью функции sendRequest(). Такая практика может привести к непреднамеренному раскрытию конфиденциальной информации в процессе передачи.




<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
// Соответствующий код - предотвращение вставки конфиденциальной информации в отправляемые данные
def sendUserData(userId: String): Unit = {
  // Получение данных о пользователе
  val userData = retrieveUserData(userId)
  
  // Отправка пользовательских данных без вставки конфиденциальной информации
  sendRequest(userData)
}

def retrieveUserData(userId: String): String = {
  // Получение данных о пользователе из базы данных
  // ...
  // Возвращаем данные пользователя в виде строки
}

def sendRequest(data: String): Unit = {
  // Отправьте данные на удаленный сервер
  // ...
}
```


В примере совместимого кода функция sendUserData() получает пользовательские данные и отправляет их на удаленный сервер, не вставляя в них конфиденциальную информацию. Благодаря прямой отправке пользовательских данных, а не конкатенации их с другими строками, код избегает риска случайного включения конфиденциальной информации в отправляемые данные.

Важно аккуратно обращаться с конфиденциальной информацией и избегать ненужных включений в передаваемые данные. Правильная работа с данными включает использование шифрования, безопасных протоколов (например, HTTPS) и следование соответствующим стандартам и рекомендациям по безопасности для защиты конфиденциальных данных во время передачи.



## Подделка межсайтовых запросов (CSRF)

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
// Несоответствующий код - отсутствие защиты CSRF
def transferFunds(request: Request): Response = {
  val sourceAccount = request.getParameter("sourceAccount")
  val destinationAccount = request.getParameter("destinationAccount")
  val amount = request.getParameter("amount")
  
  // Выполните логику перевода средств
  // ...
  
  // Возврат ответа
  // ...
}
```

В коде, не соответствующем требованиям, функция transferFunds уязвима для атак CSRF, поскольку в ней отсутствует защита CSRF. Злоумышленник может обманом заставить пользователя неосознанно выполнить вредоносный перевод средств, создав поддельный запрос и обманом заставив пользователя перейти по вредоносной ссылке или отправить форму.




<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
// Соответствующий код - защита от CSRF с помощью токенов
def transferFunds(request: Request): Response = {
  val sourceAccount = request.getParameter("sourceAccount")
  val destinationAccount = request.getParameter("destinationAccount")
  val amount = request.getParameter("amount")
  
  // Проверьте токен CSRF
  val csrfToken = request.getParameter("csrfToken")
  if (!validateCsrfToken(csrfToken)) {
    // Проверка токена CSRF не удалась, обработайте ошибку или верните соответствующий ответ
    // ...
  }
  
  // Выполните логику перевода средств
  // ...
  
  // Возврат ответа
  // ...
}

def validateCsrfToken(csrfToken: String): Boolean = {
  // Проверяем CSRF-токен на соответствие хранимому значению или сеансовому токену
  // Возвращаем true, если токен действителен, false в противном случае
  // ...
}
```


В совместимом коде добавлен механизм защиты от CSRF с помощью токенов. Функция transferFunds теперь ожидает токен CSRF как часть параметров запроса. Перед выполнением логики перевода средств она проверяет токен с помощью функции validateCsrfToken. Если проверка токена не удается, можно выполнить соответствующую обработку ошибок или генерацию ответа. Реализуя защиту от CSRF, код снижает риск несанкционированного перевода средств с помощью CSRF-атак.




## Использование жесткого пароля

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
// Несоответствующий код - жестко заданный пароль
def authenticate(username: String, password: String): Boolean = {
  // Жестко закодированный пароль для аутентификации
  if (password == "myPassword123") {
    // Аутентификация прошла успешно
    true
  } else {
    // Аутентификация не удалась
    false
  }
}
```

В коде, не соответствующем требованиям, функция authenticate использует для аутентификации жестко заданный пароль. Хранение паролей непосредственно в исходном коде представляет собой риск для безопасности, поскольку в этом случае пароль легко доступен любому, кто имеет доступ к коду. В случае компрометации или утечки кода злоумышленник может легко получить пароль и несанкционированный доступ.





<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
// Соответствующий код - использование безопасного хранения паролей
def authenticate(username: String, password: String): Boolean = {
  // Получите хэш сохраненного пароля пользователя из защищенной базы данных или механизма хранения паролей
  val storedPasswordHash = getStoredPasswordHash(username)
  
  // Сравните введенный пароль с хэшем сохраненного пароля, используя безопасный алгоритм хэширования паролей
  val isPasswordValid = verifyPassword(password, storedPasswordHash)
  
  isPasswordValid
}

def getStoredPasswordHash(username: String): String = {
  // Получите хэш сохраненного пароля пользователя из защищенной базы данных или механизма хранения паролей
  // ...
}

def verifyPassword(password: String, storedPasswordHash: String): Boolean = {
  // Используйте безопасный алгоритм хэширования пароля (например, bcrypt, Argon2, scrypt) для проверки пароля
  // Сравните хэш пароля, полученный из введенного пароля, с хэшем хранящегося пароля
  // Возвращаем true, если пароль верен, false - в противном случае
  // ...
}
```

В совместимом коде пароль не записывается в исходный код. Вместо этого он надежно хранится в базе данных или в защищенном механизме хранения паролей. Функция аутентификации получает хэш сохраненного пароля пользователя и сравнивает его с введенным паролем с помощью безопасного алгоритма хэширования пароля (например, bcrypt, Argon2, scrypt). Это гарантирует, что фактическое значение пароля никогда не будет открыто или сохранено напрямую, а для сравнения будет использоваться только хэш-представление. Благодаря использованию методов безопасного хранения и хэширования паролей код снижает риск, связанный с жестким кодированием паролей, и повышает общую безопасность приложения.






## Сломанный или рискованный криптоалгоритм

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
import java.security.MessageDigest

// Несоответствующий код - использует слабый алгоритм хэширования MD5
def hashPassword(password: String): String = {
  val md = MessageDigest.getInstance("MD5")
  val bytes = password.getBytes("UTF-8")
  val digest = md.digest(bytes)
  val hashedPassword = digest.map("%02x".format(_)).mkString
  hashedPassword
}
```


В коде, не соответствующем требованиям, функция hashPassword использует слабый алгоритм хэширования MD5 для хэширования пароля. MD5 считается неработающим и небезопасным для криптографических целей из-за его уязвимости к атакам на столкновения и наличия более безопасных альтернатив.





<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
import java.security.MessageDigest

// Соответствующий код - использует безопасный алгоритм хэширования SHA-256
def hashPassword(password: String): String = {
  val md = MessageDigest.getInstance("SHA-256")
  val bytes = password.getBytes("UTF-8")
  val digest = md.digest(bytes)
  val hashedPassword = digest.map("%02x".format(_)).mkString
  hashedPassword
}
```


В совместимом коде функция hashPassword использует безопасный алгоритм хэширования SHA-256 вместо MD5. SHA-256 - это широко распространенная и более сильная криптографическая хэш-функция. Она лучше противостоит атакам на столкновения и считается более безопасной для хэширования конфиденциальной информации, такой как пароли.

Благодаря использованию безопасного криптографического алгоритма, такого как SHA-256, совместимый код снижает риск, связанный с неработающими или рискованными криптоалгоритмами, и повышает общую безопасность приложения.




## Недостаточная энтропия

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
import scala.util.Random

// Несоответствующий код - использует Random.nextInt без достаточной энтропии
def generateOTP(): String = {
  val otp = Random.nextInt(9999).toString
  otp
}
```


В коде, не соответствующем требованиям, функция generateOTP пытается сгенерировать одноразовый пароль (OTP), используя Random.nextInt для генерации случайного числа от 0 до 9999. Однако класс Random в Scala использует алгоритм линейного конгруэнтного генератора (LCG), который может не обеспечивать достаточную энтропию для генерации безопасных случайных чисел.





<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
import java.security.SecureRandom
import scala.util.Random

// Соответствующий код - использует SecureRandom для генерации OTP с достаточной энтропией
def generateOTP(): String = {
  val secureRandom = new SecureRandom()
  val otp = secureRandom.nextInt(10000).toString
  otp
}
```

В совместимом коде функция generateOTP использует SecureRandom вместо Random для генерации OTP. SecureRandom - это криптографически сильный генератор случайных чисел, который обеспечивает достаточную энтропию для генерации безопасных случайных чисел.

Благодаря использованию SecureRandom совместимый код гарантирует, что генерируемые OTP обладают более высокой энтропией и более устойчивы к атакам типа "угадай или перебери". Это повышает безопасность приложения, которое использует ПОО для аутентификации или других чувствительных к безопасности операций.



## Межсайтовый скриптинг (XSS)

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
import scala.xml.NodeSeq

// Несоответствующий код - уязвимы для XSS
def displayMessage(message: String): NodeSeq = {
  <div>{message}</div>
}
```

В коде, не соответствующем требованиям, функция displayMessage принимает параметр message, который непосредственно интерполируется в XML-элемент с помощью синтаксиса {}. Этот код уязвим для атак межсайтового скриптинга (XSS), так как не обеспечивает надлежащего экранирования или санации параметра message. Злоумышленник может внедрить в сообщение вредоносные скрипты или HTML-теги, что приведет к потенциальным рискам безопасности.





<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
import scala.xml.{NodeSeq, Text}

// Соответствующий код - правильно экранирует сообщение для предотвращения XSS
def displayMessage(message: String): NodeSeq = {
  <div>{Text(message)}</div>
}
```


В совместимом коде функция displayMessage использует класс Text из пакета scala.xml, чтобы правильно экранировать параметр message. Класс Text гарантирует, что все специальные символы в сообщении будут закодированы правильно, что предотвращает внедрение вредоносных скриптов или HTML-тегов.

Используя класс Text для экранирования параметра message, совместимый код снижает риск XSS-атак и гарантирует, что отображаемое сообщение будет отображаться как обычный текст, а не интерпретироваться как HTML или код скрипта. Это повышает безопасность приложения и защищает пользователей от потенциальных XSS-уязвимостей.





## SQL-инъекция

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
import java.sql.{Connection, DriverManager, ResultSet}

// Несоответствующий код - уязвимость к SQL-инъекциям
def getUser(userId: String): Option[String] = {
  val query = s"SELECT name FROM users WHERE id = $userId"
  
  var connection: Connection = null
  var result: Option[String] = None
  
  try {
    connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/mydb", "username", "password")
    val statement = connection.createStatement()
    val resultSet = statement.executeQuery(query)
    if (resultSet.next()) {
      result = Some(resultSet.getString("name"))
    }
  } catch {
    case e: Exception => e.printStackTrace()
  } finally {
    if (connection != null) {
      connection.close()
    }
  }
  
  result
}
```

В коде, не соответствующем требованиям, функция getUser принимает параметр userId и напрямую интерполирует его в строку SQL-запроса. Этот код уязвим для атак SQL-инъекций, поскольку пользовательский ввод не санирован и не параметризован должным образом. Злоумышленник может манипулировать параметром userId для выполнения произвольных SQL-запросов, что может привести к получению несанкционированного доступа к базе данных или нарушению целостности данных.




<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
import java.sql.{Connection, DriverManager, PreparedStatement, ResultSet}

// Соответствующий код - использование параметризованных запросов для предотвращения SQL-инъекций
def getUser(userId: String): Option[String] = {
  val query = "SELECT name FROM users WHERE id = ?"
  
  var connection: Connection = null
  var result: Option[String] = None
  
  try {
    connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/mydb", "username", "password")
    val statement = connection.prepareStatement(query)
    statement.setString(1, userId)
    val resultSet = statement.executeQuery()
    if (resultSet.next()) {
      result = Some(resultSet.getString("name"))
    }
  } catch {
    case e: Exception => e.printStackTrace()
  } finally {
    if (connection != null) {
      connection.close()
    }
  }
  
  result
}
```

В совместимом коде функция getUser использует параметризованные запросы для предотвращения атак SQL-инъекций. Вместо того чтобы напрямую интерполировать параметр userId в SQL-запрос, код использует подготовленный запрос и связывает параметр с помощью метода setString. Такой подход обеспечивает правильную обработку пользовательского ввода и предотвращает выполнение вредоносных SQL-запросов.

Используя параметризованные запросы, совместимый код снижает риск SQL-инъекций и обеспечивает безопасность операций с базой данных. Это защищает от несанкционированного доступа и помогает поддерживать целостность данных в приложении.



## Внешнее управление именем или путем файла

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
import java.io.File

// Несоответствующий код - уязвимость к внешнему контролю имени файла или пути к нему
def readFile(fileName: String): String = {
  val file = new File(fileName)
  val content = scala.io.Source.fromFile(file).mkString
  content
}
```


В коде, не соответствующем требованиям, функция readFile принимает параметр fileName, который используется для создания объекта File для чтения содержимого файла. Однако этот код уязвим для внешнего контроля имени файла или пути к нему, поскольку он напрямую использует параметр fileName без какой-либо проверки или санации. Злоумышленник может манипулировать параметром fileName для чтения произвольных файлов из системы, что может привести к раскрытию конфиденциальной информации или нарушению безопасности приложения.





<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
import java.io.File

// Соответствующий код - проверяет и обеззараживает имя файла
def readFile(fileName: String): Option[String] = {
  if (!fileName.contains("..") && fileName.matches("[a-zA-Z0-9]+\\.txt")) {
    val file = new File(fileName)
    val content = scala.io.Source.fromFile(file).mkString
    Some(content)
  } else {
    None
  }
}
```

В совместимом коде функция readFile проверяет и санирует параметр fileName перед обращением к файлу. Код проверяет, не содержит ли имя файла ..., которое обычно используется в атаках обхода пути для перехода к родительским каталогам. Кроме того, код использует шаблон регулярного выражения, чтобы убедиться, что имя файла состоит только из буквенно-цифровых символов и заканчивается расширением .txt (вы можете модифицировать шаблон в соответствии с вашими требованиями).

Проверяя и санируя имя файла, совместимый код снижает риск внешнего контроля имени файла или пути к нему. Он обеспечивает доступ только к файлам, соответствующим заданным критериям, что снижает вероятность несанкционированного доступа или раскрытия конфиденциальной информации.




## Генерация сообщения об ошибке, содержащего конфиденциальную информацию

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
// Несоответствующий код - сообщение об ошибке, содержащее конфиденциальную информацию
def divide(a: Int, b: Int): Int = {
  if (b != 0) {
    a / b
  } else {
    throw new ArithmeticException("Division by zero error. Numerator: " + a + ", Denominator: " + b)
  }
}
```


В коде, не соответствующем требованиям, при делении на ноль выбрасывается ArithmeticException с сообщением об ошибке, включающим значения числителя и знаменателя. Это сообщение об ошибке может содержать конфиденциальную информацию, например, фактические значения вычислений, которые могут быть использованы злоумышленником в злонамеренных целях.




<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
// Соответствующий код - общее сообщение об ошибке без важной информации
def divide(a: Int, b: Int): Int = {
  if (b != 0) {
    a / b
  } else {
    throw new ArithmeticException("Division by zero error.")
  }
}
```

В коде, соответствующем требованиям, сообщение об ошибке модифицировано, чтобы предоставить общее сообщение, не раскрывая никакой конфиденциальной информации. Вместо того чтобы указывать конкретные значения числителя и знаменателя, в сообщении об ошибке просто говорится, что произошла ошибка деления на ноль.

Избегая включения конфиденциальной информации в сообщения об ошибках, совместимый код помогает предотвратить потенциальное раскрытие конфиденциальных данных. Он следует принципу предоставления общего сообщения об ошибке, которое не раскрывает конкретных деталей вычислений, снижая риск утечки информации и защищая конфиденциальность конфиденциальных данных.


## Незащищенное хранение учетных данных

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
// Несоответствующий код - незащищенное хранение учетных данных
val username = "admin"
val password = "secretpassword"
```

В коде, не соответствующем требованиям, учетные данные (имя пользователя и пароль) хранятся непосредственно в переменных без какой-либо защиты. Хранение учетных данных в открытом виде подвергает их потенциальному несанкционированному доступу, особенно если злоумышленник получит доступ к исходному коду или среде, в которой развернут код.




<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
// Соответствующий код - безопасное хранение учетных данных
val username = readSecureValue("username")
val password = readSecureValue("password")

def readSecureValue(key: String): String = {
  // Реализуйте безопасный механизм для получения значения заданного ключа.
  // Примеры: чтение из зашифрованного файла конфигурации, получение из защищенного хранилища ключей и т. д.
  // Данная реализация зависит от конкретных требований безопасности и инфраструктуры приложения.
  // Основное внимание уделяется безопасному получению учетных данных, гарантируя, что они не хранятся непосредственно в коде.
  // Точные детали реализации выходят за рамки данного примера.
  // В идеале для безопасного хранения учетных данных следует использовать инструменты управления секретами или библиотеки.
  // Это гарантирует, что учетные данные не будут жестко закодированы в коде и к ним будет обеспечен безопасный доступ во время выполнения.
  // Кроме того, для защиты хранимых учетных данных должны быть реализованы контроль доступа и шифрование.
  // Для простоты в этом примере предполагается пользовательская функция readSecureValue(), которая безопасно извлекает значение value.
  // Фактическая реализация должна использовать установленные и проверенные методы обеспечения безопасности.
  // Данный пример призван проиллюстрировать концепцию безопасного хранения и получения учетных данных.
  // В реальных сценариях рекомендуется использовать надежное решение для управления секретами.
  // Данный фрагмент кода должен быть адаптирован в соответствии с конкретными требованиями безопасности приложения.

  // Реализация Placeholder
  if (key == "username") {
    // Получение значения имени пользователя безопасно
    "admin"
  } else if (key == "password") {
    // Получите безопасное значение пароля
    "secretpassword"
  } else {
    // Обрабатывайте другие ключи по мере необходимости
    ""
  }
}
```

В совместимом коде учетные данные не хранятся непосредственно в коде. Вместо этого используется безопасный механизм для получения значений учетных данных во время выполнения. Функция readSecureValue - это место для безопасной реализации, которая извлекает учетные данные из безопасного хранилища или решения для управления секретами. Точные детали реализации будут зависеть от конкретных требований безопасности и инфраструктуры приложения.

Благодаря безопасному хранению учетных данных и их получению во время выполнения, совместимый код помогает защитить конфиденциальную информацию от несанкционированного доступа. Он позволяет избежать риска раскрытия учетных данных в виде открытого текста и следует лучшим практикам управления учетными данными и безопасного хранения.



## Нарушение границ доверия

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
// Несоответствующий код - нарушение границ доверия
val userRole = getUserRoleFromRequest(request)
val isAdmin = checkUserRole(userRole)

def getUserRoleFromRequest(request: Request): String = {
  // Извлечение роли пользователя из параметра запроса без надлежащей валидации
  // Данный код предполагает, что роль пользователя указывается непосредственно в запросе
  // без какой-либо санации или проверки валидности
  request.getParameter("role")
}

def checkUserRole(userRole: String): Boolean = {
  // Выполните проверку, чтобы определить, имеет ли пользователь административные привилегии.
  // В этом несоответствующем коде проверка основывается только на значении роли пользователя
  // без какой-либо дополнительной валидации или проверки
  userRole.toLowerCase() == "admin"
}
```

В коде, не соответствующем требованиям, происходит нарушение границ доверия, когда роль пользователя извлекается непосредственно из параметра запроса без надлежащей проверки или санации. Код предполагает, что роль пользователя, указанная в запросе, заслуживает доверия, и использует ее для определения наличия у пользователя административных привилегий. Однако такой подход небезопасен, поскольку он опирается исключительно на предоставленное пользователем значение без дополнительной проверки или подтверждения.





<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
// Соответствующий код - надлежащее подтверждение роли пользователя
val userRole = getUserRoleFromRequest(request)
val isAdmin = checkUserRole(userRole)

def getUserRoleFromRequest(request: Request): String = {
  // Извлеките роль пользователя из параметра запроса и выполните соответствующую проверку
  // Проверяем и обеззараживаем вводимые пользователем данные, чтобы предотвратить нарушение границ доверия
  val rawUserRole = request.getParameter("role")
  validateUserRole(rawUserRole)
}

def validateUserRole(userRole: String): String = {
  // Выполните надлежащую проверку и санацию роли пользователя.
  // Это может включать такие проверки, как проверка того, что роль пользователя находится в допустимом наборе значений,
  // проверка по предопределенному списку ролей или использование специальной библиотеки проверки ролей.
  // Точная логика проверки зависит от конкретных требований и дизайна приложения.
  // В данном примере предполагается простая валидация в демонстрационных целях.
  if (userRole.toLowerCase() == "admin" || userRole.toLowerCase() == "user") {
    userRole.toLowerCase()
  } else {
    // При необходимости обработайте недействительные роли пользователей, например, назначьте роль по умолчанию или выбросьте исключение
    "guest"
  }
}

def checkUserRole(userRole: String): Boolean = {
  // Выполните проверку, чтобы определить, есть ли у пользователя административные привилегии
  // Роль пользователя была должным образом подтверждена до достижения этого пункта
  userRole == "admin"
}
```


В совместимом коде выполняется надлежащая валидация и санация роли пользователя. Функция getUserRoleFromRequest извлекает роль пользователя из параметра запроса и передает ее функции validateUserRole для проверки. Функция validateUserRole выполняет соответствующие проверки, чтобы убедиться, что роль пользователя действительна и находится в пределах ожидаемого набора значений. В этом примере валидация представляет собой простую проверку разрешенных ролей, но в реальных сценариях следует использовать более сложную логику валидации и библиотеки.

Проверяя и санируя роль пользователя, совместимый код предотвращает нарушение границ доверия и гарантирует, что для определения наличия у пользователя административных привилегий используются только допустимые и доверенные значения. Это помогает защитить от несанкционированного доступа и поддерживает целостность границы доверия.






## Недостаточно защищенные учетные данные

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
// Несоответствующий код - недостаточно защищенные учетные данные
val username = "admin"
val password = "password"

val connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/mydb", username, password)
```

В коде, не соответствующем требованиям, имя пользователя и пароль для подключения к базе данных жестко закодированы непосредственно в исходном коде. Такая практика небезопасна, поскольку открывает доступ к конфиденциальным учетным данным всем, кто имеет доступ к коду. Жесткое кодирование учетных данных облегчает злоумышленникам их определение и использование, особенно если исходный код доступен или случайно просочился.




<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
// Соответствующий код - защищённые учетные данные
val username = readUsernameFromConfig()
val password = readPasswordFromConfig()

val connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/mydb", username, password)

def readUsernameFromConfig(): String = {
  // Считываем имя пользователя из защищенного конфигурационного файла или переменной окружения
  // Это гарантирует, что учетные данные не будут непосредственно жестко закодированы в исходном коде
  // и хранятся отдельно от репозитория кода
  // Конкретный метод получения имени пользователя зависит от механизма конфигурации приложения.
  // например, чтение из файла свойств, использование безопасного хранилища или получение из переменных окружения.
  // В данном примере в демонстрационных целях предполагается чтение из файла свойств
  val properties = new Properties()
  properties.load(new FileInputStream("config.properties"))
  properties.getProperty("db.username")
}

def readPasswordFromConfig(): String = {
  // Считывание пароля из защищенного конфигурационного файла или переменной окружения
  // Как и имя пользователя, пароль должен храниться отдельно от исходного кода
  val properties = new Properties()
  properties.load(new FileInputStream("config.properties"))
  properties.getProperty("db.password")
}
```


В совместимом коде имя пользователя и пароль извлекаются из защищенного конфигурационного файла (config.properties), а не вводятся непосредственно в исходный код. Такое отделение учетных данных от кода гарантирует, что конфиденциальная информация не будет раскрыта в самой кодовой базе. Конкретный метод получения учетных данных может зависеть от механизма конфигурации приложения, например чтение из файла свойств, использование защищенного хранилища или получение из переменных окружения.

Защищая учетные данные в отдельном файле конфигурации или переменной среды, совместимый код снижает риск случайного раскрытия конфиденциальной информации и помогает сохранить конфиденциальность учетных данных. Это также позволяет упростить управление учетными данными в различных средах без внесения изменений в исходный код.




## Ограничение ссылки на внешние сущности XML

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
// Несоответствующий код - неограниченная ссылка на сущность XML
import scala.xml.XML

val xml = XML.loadString("""
  <?xml version="1.0" encoding="UTF-8"?>
  <!DOCTYPE foo [
    <!ENTITY xxe SYSTEM "file:///etc/passwd">
  ]>
  <root>&xxe;</root>
""")

// Обработка данных XML
```

В коде, не соответствующем требованиям, XML-документ загружается с помощью метода XML.loadString без каких-либо явных ограничений на ссылки на внешние сущности XML. Это может привести к атакам XML External Entity (XXE), когда злоумышленник может включить внешние сущности, такие как локальные файлы, и потенциально прочитать конфиденциальные данные или выполнить другие вредоносные действия.





<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
// Соответствующий код - ограниченная ссылка на сущность XML
import scala.xml.{Elem, XML}
import javax.xml.XMLConstants
import javax.xml.parsers.DocumentBuilderFactory

// Настройка безопасного разбора XML
val factory = DocumentBuilderFactory.newInstance()
factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true)
factory.setExpandEntityReferences(false)

val builder = factory.newDocumentBuilder()
val xml = XML.withSAXParser(builder).loadString("""
  <?xml version="1.0" encoding="UTF-8"?>
  <!DOCTYPE foo [
    <!ENTITY xxe SYSTEM "file:///etc/passwd">
  ]>
  <root>&xxe;</root>
""")

// Обработка данных XML
```


В совместимом коде приняты дополнительные меры для ограничения ссылок на XML-сущности и предотвращения XXE-атак. Для создания безопасного парсера XML используется фабрика javax.xml.parsers.DocumentBuilderFactory. Включив функцию FEATURE_SECURE_PROCESSING и отключив опцию ExpandEntityReferences, парсер гарантирует, что ссылки на внешние сущности XML не будут разрешены или расширены.

Метод XML.withSAXParser используется для применения безопасного парсера к XML-документу. Это гарантирует, что обработка XML будет выполняться с ограниченным поведением ссылок на сущности.

Реализуя эти ограничения на ссылки на XML-сущности, совместимый код снижает риск XXE-атак и защищает от несанкционированного раскрытия конфиденциальной информации из внешних сущностей.




## Библиотека PHPMailer

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
// Несоответствующий код - использование устаревшей версии библиотеки
import org.apache.commons.codec.digest.DigestUtils

val password = "password123"
val hashedPassword = DigestUtils.sha1Hex(password)
```

В несоответствующем коде для хэширования пароля по алгоритму SHA-1 используется библиотека Apache Commons Codec. Однако использование алгоритма SHA-1 для хеширования паролей считается небезопасным и устаревшим. Он подвержен различным атакам, таким как атаки на столкновение и атаки на предварительный образ, что делает его непригодным для безопасного хранения паролей.





<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
// Соответствующий код - использование безопасной и актуальной версии библиотеки
import java.security.MessageDigest

val password = "password123"
val sha256 = MessageDigest.getInstance("SHA-256")
val hashedPassword = sha256.digest(password.getBytes).map("%02x".format(_)).mkString
```


В совместимом коде класс java.security.MessageDigest используется для хэширования пароля с помощью алгоритма SHA-256, который является более безопасным, чем SHA-1. Для получения экземпляра класса MessageDigest вызывается метод getInstance с именем алгоритма "SHA-256".

Метод digest используется для вычисления хэш-значения пароля путем преобразования его в байты и применения алгоритма SHA-256. Затем полученный хэш преобразуется в шестнадцатеричное строковое представление с помощью методов map и mkString.

Благодаря использованию такого безопасного и современного алгоритма, как SHA-256, совместимый код обеспечивает более надежное и безопасное хеширование паролей, снижая риск их компрометации из-за использования уязвимых и устаревших компонентов. Важно регулярно обновлять зависимости и библиотеки, чтобы гарантировать использование последних версий с исправлениями и исправлениями безопасности.




## Неправильная проверка сертификата с несоответствием хоста

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
// Несоответствующий код - неправильная проверка сертификата
import java.net.URL
import java.net.HttpURLConnection

val url = new URL("https://example.com")
val connection = url.openConnection().asInstanceOf[HttpURLConnection]
connection.setRequestMethod("GET")

// Отключить проверку имени хоста
connection.setHostnameVerifier((_, _) => true)

val responseCode = connection.getResponseCode()
```

В коде, не соответствующем требованиям, создается URL для конечной точки "https://example.com" и открывается соединение с помощью метода openConnection(). Метод setHostnameVerifier используется для отключения проверки имени хоста, что означает, что сертификат, представленный сервером, не будет проверяться на соответствие хосту.





<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
// Соответствующий код - надлежащее подтверждение сертификата
import java.net.URL
import java.net.HttpURLConnection
import javax.net.ssl.HttpsURLConnection
import javax.net.ssl.SSLContext

val url = new URL("https://example.com")
val connection = url.openConnection().asInstanceOf[HttpsURLConnection]
connection.setRequestMethod("GET")

// Включите правильную проверку имени хоста
val sslContext = SSLContext.getInstance("TLS")
sslContext.init(null, null, null)
connection.setSSLSocketFactory(sslContext.getSocketFactory())

val responseCode = connection.getResponseCode()
```


В совместимом коде класс HttpsURLConnection используется вместо HttpURLConnection для установления HTTPS-соединения, которое необходимо для безопасной связи. Класс SSLContext используется для инициализации SSL-контекста с параметрами по умолчанию.

Затем на объекте соединения вызывается метод setSSLSocketFactory, чтобы установить фабрику сокетов SSL из инициализированного SSL-контекста. Это гарантирует, что базовая реализация SSL выполнит надлежащую проверку сертификата и имени хоста.

Благодаря использованию класса HttpsURLConnection и включению надлежащей проверки имени хоста совместимый код гарантирует, что сертификат, представленный сервером, будет проверен на соответствие хосту, что снижает риск подключения к серверу с несоответствующим или недействительным сертификатом. Для создания безопасных и надежных соединений важно выполнять надлежащую проверку сертификатов.




## Неправильная аутентификация

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
// Несоответствующий код - неправильная аутентификация
import java.util.Scanner

val scanner = new Scanner(System.in)
println("Enter username:")
val username = scanner.nextLine()
println("Enter password:")
val password = scanner.nextLine()

// Выполните логику аутентификации
val isAuthenticated = authenticate(username, password)

if (isAuthenticated) {
  println("Authentication successful")
} else {
  println("Authentication failed")
}

def authenticate(username: String, password: String): Boolean = {
  // Логика аутентификации находится здесь
  // ...
  true // Фиктивная логика аутентификации для демонстрационных целей
}
```

В коде, не соответствующем требованиям, процесс аутентификации основан на чтении имени пользователя и пароля из стандартного ввода с помощью класса Scanner. Затем учетные данные передаются в функцию authenticate, которая выполняет логику аутентификации. Однако такой подход небезопасен, поскольку подвергает конфиденциальные учетные данные потенциальному подслушиванию.





<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
// Соответствующий код - надлежащая аутентификация
import java.io.Console

val console: Console = System.console()
val username = console.readLine("Enter username: ")
val password = console.readPassword("Enter password: ")

// Выполните логику аутентификации
val isAuthenticated = authenticate(username, password)

if (isAuthenticated) {
  println("Authentication successful")
} else {
  println("Authentication failed")
}

def authenticate(username: String, password: Array[Char]): Boolean = {
  // Логика аутентификации находится здесь
  // ...
  true // Фиктивная логика аутентификации для демонстрации
}
```


В совместимом коде процесс аутентификации использует класс Console для чтения имени пользователя и пароля из консоли. Метод readLine используется для считывания имени пользователя, а метод readPassword - для безопасного считывания пароля в виде массива символов, а не строки обычного текста.

Благодаря использованию класса Console совместимый код избегает раскрытия конфиденциальных учетных данных в виде обычного текста и обеспечивает более безопасный подход к обработке пользовательского ввода для аутентификации.




## Фиксация сеанса

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
// Несоответствующий код - уязвимость фиксации сеанса
import javax.servlet.http.{HttpServletRequest, HttpServletResponse}

def login(request: HttpServletRequest, response: HttpServletResponse): Unit = {
  val sessionId = request.getParameter("sessionid")
  // Выполните логику входа в систему
  // ...
  val newSessionId = generateNewSessionId()
  request.getSession(true).setAttribute("sessionid", newSessionId)
  response.sendRedirect("/dashboard")
}

def generateNewSessionId(): String = {
  // Логика генерирования нового идентификатора сессии находится здесь
  // ...
  "newSessionId" // Фиктивный идентификатор сессии для демонстрационных целей
}
```

В коде, не соответствующем требованиям, функция login получает HTTP-запрос и объекты ответа. Она извлекает параметр sessionid из запроса, выполняет логику входа, генерирует новый идентификатор сессии с помощью функции generateNewSessionId и устанавливает новый идентификатор сессии в качестве атрибута в сессии. Однако этот код уязвим для атак с фиксацией сеанса, поскольку принимает параметр sessionid из ненадежного источника, не аннулируя существующую сессию.





<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
// Соответствующий код - защищены от фиксации сеанса
import javax.servlet.http.{HttpServletRequest, HttpServletResponse}
import java.util.UUID

def login(request: HttpServletRequest, response: HttpServletResponse): Unit = {
  val newSessionId = generateNewSessionId()
  request.changeSessionId() // Признать недействительным идентификатор существующей сессии
  request.getSession(true).setAttribute("sessionid", newSessionId)
  response.sendRedirect("/dashboard")
}

def generateNewSessionId(): String = {
  UUID.randomUUID().toString // Сгенерируйте новый идентификатор сеанса с помощью безопасного метода
}
```


В коде, соответствующем требованиям, функция входа в систему генерирует новый идентификатор сессии с помощью безопасного метода, например UUID.randomUUID(). Перед установкой нового идентификатора сессии код аннулирует все существующие сессии, вызывая request.changeSessionId(). Это гарантирует, что все ранее установленные идентификаторы сессий будут аннулированы и будет установлена новая сессия.

Генерируя новый идентификатор сессии и аннулируя все существующие сессии, совместимый код защищает от атак фиксации сессий, гарантируя, что каждый пользователь получает уникальный и безопасный идентификатор сессии при входе в систему.




## Включение функциональности из недоверенного управления

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
// Несоответствующий код - включение функциональности из недоверенного управления
def processTemplate(templateName: String): String = {
  val template = loadTemplate(templateName)
  template.render()
}

def loadTemplate(templateName: String): Template = {
  // Загрузка файла шаблона из недоверенного источника
  // ...
  Template.fromFile(templateName) // Небезопасное включение шаблона
}
```

В коде, не соответствующем требованиям, функция processTemplate принимает параметр templateName и пытается загрузить шаблон с помощью функции loadTemplate. Однако код уязвим для включения функциональности из недоверенного элемента управления, поскольку он напрямую включает шаблон, указанный параметром templateName, без надлежащей проверки или санации.





<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
// Соответствующий код - защита от включения функциональности из недоверенного управления
def processTemplate(templateName: String): String = {
  val template = loadTemplate(templateName)
  template.render()
}

def loadTemplate(templateName: String): Template = {
  if (isValidTemplateName(templateName)) {
    // Загрузите шаблон из надежного источника
    // ...
    Template.fromFile(templateName) // Безопасное включение шаблона
  } else {
    throw new IllegalArgumentException("Invalid template name")
  }
}

def isValidTemplateName(templateName: String): Boolean = {
  // Реализуйте логику проверки имени шаблона
  // ...
  // Возвращает true, если имя шаблона валидно, false - в противном случае
}
```


В совместимом коде функция loadTemplate включает дополнительную логику проверки, вводя функцию isValidTemplateName. Перед загрузкой шаблона код проверяет, является ли имя шаблона действительным, вызывая функцию isValidTemplateName. Если имя шаблона достоверно, код переходит к загрузке шаблона из доверенного источника с помощью функции Template.fromFile. Однако если имя шаблона окажется недействительным, то для обработки ошибки будет выброшено исключение.

Реализуя правильную проверку имени шаблона, совместимый код защищает от включения функциональности из недоверенного управления, гарантируя, что загружаются и отображаются только доверенные шаблоны.


## Загрузка кода без проверки целостности

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
import scala.sys.process._

def downloadAndExecute(url: String): Unit = {
  val command = s"curl $url | bash"
  command.!
}
```

В коде, не соответствующем требованиям, функция downloadAndExecute принимает на вход URL, загружает код с помощью curl, а затем передает вывод в bash для выполнения. Однако код уязвим для загрузки кода без проверки целостности. Он напрямую выполняет загруженный код, не проверяя его целостность или подлинность.




<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
import scala.sys.process._

def downloadAndExecute(url: String, checksum: String): Unit = {
  val command = s"curl $url | bash"
  val downloadedCode = command.!!

  if (verifyIntegrity(downloadedCode, checksum)) {
    // Выполните загруженный код
    // ...
  } else {
    throw new SecurityException("Code integrity check failed")
  }
}

def verifyIntegrity(code: String, checksum: String): Boolean = {
  // Выполните проверку целостности, сравнив контрольную сумму кода с ожидаемой контрольной суммой
  // ...
  // Возвращает true, если целостность кода достоверна, false - в противном случае
}
```


В совместимом коде функция downloadAndExecute принимает дополнительный параметр checksum, который представляет собой ожидаемую контрольную сумму загруженного кода. После загрузки кода с помощью curl код выполняет проверку целостности, вызывая функцию verifyIntegrity. Функция verifyIntegrity сравнивает контрольную сумму загруженного кода с ожидаемой контрольной суммой. Если проверка целостности пройдена, код переходит к выполнению загруженного кода. Однако если проверка целостности не проходит, то выбрасывается SecurityException для обработки потенциального риска безопасности.

Введя проверку целостности, совместимый код снижает риск выполнения загруженного кода, который мог быть подделан или скомпрометирован во время транспортировки. Он гарантирует, что загруженный код будет проверен на соответствие ожидаемой контрольной сумме перед выполнением.



## Десериализация недоверенных данных

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
import java.io.{ByteArrayInputStream, ObjectInputStream}

def deserializeObject(data: Array[Byte]): Any = {
  val stream = new ByteArrayInputStream(data)
  val objectInputStream = new ObjectInputStream(stream)
  val obj = objectInputStream.readObject()
  objectInputStream.close()
  obj
}
```

В коде, не соответствующем требованиям, функция deserializeObject принимает массив байтов (данные) и пытается десериализовать его с помощью ObjectInputStream. Однако этот код уязвим для атак десериализации, поскольку он напрямую десериализует недоверенные данные без какой-либо проверки или санации. Злоумышленник может предоставить злонамеренно созданные сериализованные данные, что приведет к таким проблемам безопасности, как удаленное выполнение кода или отказ в обслуживании.




<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
import java.io.{ByteArrayInputStream, ObjectInputStream}
import java.util.Base64

def deserializeObject(data: Array[Byte]): Any = {
  val stream = new ByteArrayInputStream(data)
  val objectInputStream = new ObjectInputStream(stream)

  // Выполните проверку ввода и обеззараживание данных
  // Пример: Убедитесь, что данные получены из надежного источника или имеют определенный формат

  val obj = objectInputStream.readObject()
  objectInputStream.close()
  obj
}
```


В совместимом коде перед десериализацией выполняются дополнительные шаги по проверке ввода и обеззараживанию данных. Эти шаги могут варьироваться в зависимости от конкретных требований вашего приложения, но некоторые общие практики включают:

* Проверка того, что данные поступают из надежного источника.
* Убедиться, что данные имеют определенный ожидаемый формат или структуру.
* Применение проверок целостности данных, например, проверка цифровых подписей или контрольных сумм.
* Фильтрация или отбраковка данных, которые не соответствуют необходимым критериям.

Реализуя надлежащую проверку ввода и санацию данных, совместимый код снижает риск атак десериализации, гарантируя, что десериализуются только доверенные и ожидаемые данные. Это помогает предотвратить выполнение вредоносного кода или использование уязвимостей через десериализацию.



## Недостаточное ведение журнала

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
import java.io.{FileWriter, IOException}

def performSensitiveOperation(input: String): Unit = {
  try {
    // Выполните чувствительную операцию здесь

    // Занесите в журнал сообщение об успехе
    val logMessage = s"Sensitive operation successful for input: $input"
    val fileWriter = new FileWriter("application.log", true)
    fileWriter.write(logMessage)
    fileWriter.close()
  } catch {
    case e: Exception =>
      // Сообщение об ошибке в журнале
      val logMessage = s"Error performing sensitive operation for input: $input - ${e.getMessage}"
      val fileWriter = new FileWriter("application.log", true)
      fileWriter.write(logMessage)
      fileWriter.close()
  }
}
```

В коде, не соответствующем требованиям, функция performSensitiveOperation выполняет конфиденциальную операцию и записывает сообщения об успехе и ошибках в файл журнала. Однако реализация протоколирования неадекватна и подвержена ряду проблем:

* Отсутствие уровней серьезности журнала: Код не различает уровни серьезности (например, INFO, WARN, ERROR), что затрудняет определение приоритетов и надлежащую реакцию на различные типы событий журнала.
* Недостаточная детализация журналов: В сообщениях журнала не хватает подробностей для понимания контекста и причины событий в журнале, что затрудняет поиск и анализ неисправностей.
* Ручная обработка файлов: Код вручную обрабатывает запись и закрытие файлов, что может привести к утечке ресурсов и потенциальным конфликтам доступа к файлам.




<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
import org.slf4j.{Logger, LoggerFactory}

// Определите экземпляр регистратора
val logger: Logger = LoggerFactory.getLogger(getClass)

def performSensitiveOperation(input: String): Unit = {
  try {
    // Выполните чувствительную операцию здесь

    // Занесите в журнал сообщение об успехе с соответствующим уровнем серьезности
    logger.info(s"Sensitive operation successful for input: $input")
  } catch {
    case e: Exception =>
      // Зафиксируйте сообщение об ошибке с соответствующим уровнем серьезности и трассировкой стека исключений
      logger.error(s"Error performing sensitive operation for input: $input", e)
  }
}
```


В совместимом коде для решения проблемы недостаточного протоколирования используется фреймворк протоколирования (например, SLF4J). Код использует возможности фреймворка для обработки уровней серьезности журнала, предоставления содержательной информации о журнале, а также для записи файлов и управления ресурсами.

Основные улучшения в совместимом коде:

* Фреймворк ведения логов: Для обработки операций протоколирования в коде используется установленный фреймворк протоколирования (SLF4J), который обеспечивает более надежные и гибкие функции протоколирования.
* Уровни серьезности журналов: Код включает соответствующие уровни серьезности журнала (например, INFO для успешного выполнения, ERROR для ошибок), чтобы различать различные типы событий журнала.
* Расширенные подробности журнала: Код включает в сообщения журнала соответствующую контекстную информацию, такую как входное значение и трассировку стека исключений для сценариев ошибок, чтобы помочь в устранении неполадок и анализе.
* Управляемая фреймворком обработка файлов: Фреймворк протоколирования берет на себя запись файлов и управление ресурсами, устраняя необходимость в ручной работе с файлами и снижая риск утечки ресурсов или конфликтов доступа к файлам.

Применяя надлежащий фреймворк протоколирования и следуя лучшим практикам протоколирования, совместимый код повышает эффективность и полезность журналов, способствуя лучшему мониторингу, устранению неполадок и реагированию на инциденты в приложении.


## Неправильная нейтрализация выходных данных в журналах

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
import java.io.{FileWriter, IOException}

def logSensitiveInformation(input: String): Unit = {
  try {
    // Регистрация конфиденциальной информации без надлежащей нейтрализации выходных данных
    val logMessage = s"Sensitive input received: $input"
    val fileWriter = new FileWriter("application.log", true)
    fileWriter.write(logMessage)
    fileWriter.close()
  } catch {
    case e: IOException =>
      println("Error writing to log file: " + e.getMessage)
  }
}
```

В коде, не соответствующем требованиям, функция logSensitiveInformation регистрирует конфиденциальную информацию без надлежащей нейтрализации вывода. Она напрямую конкатенирует конфиденциальное входное значение с сообщением журнала и записывает его в файл журнала. Такой подход может привести к атакам с внедрением в журнал, когда злоумышленник может манипулировать входным значением, чтобы изменить сообщение журнала или внедрить вредоносное содержимое.






<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
import org.slf4j.{Logger, LoggerFactory}
import org.apache.commons.text.StringEscapeUtils

// Определите экземпляр регистратора
val logger: Logger = LoggerFactory.getLogger(getClass)

def logSensitiveInformation(input: String): Unit = {
  try {
    // Регистрация конфиденциальной информации с надлежащей нейтрализацией вывода
    val sanitizedInput = StringEscapeUtils.escapeJava(input)
    val logMessage = s"Sensitive input received: $sanitizedInput"
    logger.info(logMessage)
  } catch {
    case e: Exception =>
      logger.error("Error logging sensitive information: " + e.getMessage)
  }
}
```


В совместимом коде применяется надлежащая нейтрализация вывода, чтобы гарантировать, что регистрируемая информация безопасна и не несет в себе уязвимостей. В коде используется метод StringEscapeUtils.escapeJava из библиотеки Apache Commons Text для экранирования специальных символов во входном значении. Это гарантирует, что все специальные символы будут правильно закодированы и не повлияют на формат журнала и не создадут уязвимости для инъекций.

Основные улучшения в совместимом коде:

* Нейтрализация вывода: В коде применяется надлежащая нейтрализация вывода с помощью метода StringEscapeUtils.escapeJava для экранирования специальных символов во входном значении перед записью в журнал.
* Фреймворк протоколирования: Код использует фреймворк протоколирования (SLF4J) для обработки операций протоколирования, обеспечивая лучшее управление и конфигурируемость журнала.
* Улучшенная обработка ошибок: Код перехватывает исключения и записывает соответствующие сообщения об ошибках, используя фреймворк протоколирования, что улучшает обработку потенциальных ошибок во время протоколирования.

Применяя надлежащую нейтрализацию выходных данных и используя структуру протоколирования, совместимый код снижает риск атак с внедрением журнала и гарантирует, что занесенная в журнал информация безопасна и точно представляет предполагаемое содержимое.




## Упущение информации, имеющей отношение к безопасности

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
import java.security.MessageDigest

def hashPassword(password: String): String = {
  val md = MessageDigest.getInstance("SHA-256")
  md.update(password.getBytes)
  val digest = md.digest()
  digest.toString
}
```

В коде, не соответствующем требованиям, функция hashPassword хэширует пароль с помощью алгоритма SHA-256. Однако в ней отсутствует важная для безопасности информация. Код только преобразует дайджест в строку с помощью стандартного метода toString, что не обеспечивает безопасного представления хэшированного пароля. Это может привести к раскрытию конфиденциальной информации и облегчить злоумышленнику обратную разработку или угадывание оригинального пароля.






<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
import java.security.MessageDigest
import java.util.Base64

def hashPassword(password: String): String = {
  val md = MessageDigest.getInstance("SHA-256")
  md.update(password.getBytes)
  val digest = md.digest()
  Base64.getEncoder.encodeToString(digest)
}
```


В совместимый код включена информация, имеющая отношение к безопасности, чтобы обеспечить безопасное представление хэшированного пароля. В коде используется класс Base64.getEncoder из пакета java.util для кодирования дайджеста в строковое представление Base64. Это обеспечивает более безопасный и стандартизированный формат для хранения и передачи хэшированного пароля.

Основные улучшения в совместимом коде:

1. Использование кодировки Base64: В коде используется метод Base64.getEncoder.encodeToString для преобразования дайджеста в строковое представление Base64, что обеспечивает безопасный и переносимый формат для хэшированного пароля.
2. Повышенная безопасность: Включая безопасное представление хэшированного пароля, совместимый код снижает риск раскрытия конфиденциальной информации и делает более сложной задачу злоумышленников по обратной разработке или угадыванию оригинального пароля.

Благодаря включению важной для безопасности информации и использованию надлежащего кодирования код, соответствующий требованиям, повышает безопасность хэшированного пароля и снижает риск раскрытия конфиденциальной информации при хранении или передаче.





## Чувствительная информация в файле журнала

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
import java.io.FileWriter

def logSensitiveInformation(data: String): Unit = {
  val fileWriter = new FileWriter("logfile.txt", true)
  fileWriter.write(s"Sensitive information: $data\n")
  fileWriter.close()
}
```

В коде, не соответствующем требованиям, функция logSensitiveInformation регистрирует конфиденциальную информацию, напрямую добавляя ее в файл журнала. Такой подход небезопасен, поскольку может привести к раскрытию конфиденциальных данных, если к файлу журнала получат доступ неавторизованные лица. Хранение конфиденциальной информации в текстовом формате повышает риск утечки данных и нарушает конфиденциальность информации.





<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
import org.slf4j.LoggerFactory

def logSensitiveInformation(data: String): Unit = {
  val logger = LoggerFactory.getLogger(getClass)
  logger.info(s"Sensitive information: $data")
}
```


В совместимом коде функция logSensitiveInformation использует фреймворк протоколирования (в данном случае SLF4J) для обработки сообщений журнала. Благодаря использованию фреймворка протоколирования конфиденциальная информация может регистрироваться безопасно и с большим контролем. Соответствующий код использует уровень журнала info, чтобы указать, что сообщение журнала содержит конфиденциальную информацию.

Основные улучшения в совместимом коде:

1. Структура ведения журнала: В коде, соответствующем требованиям, используется фреймворк для ведения журнала, который предоставляет больше возможностей, возможностей настройки и безопасности для обработки сообщений журнала.
2. Выбор уровня журнала: Код использует соответствующий уровень журнала (например, info), чтобы указать на наличие конфиденциальной информации в журнале.
3. Избегание прямого манипулирования файлами: Используя систему протоколирования, код, соответствующий требованиям, избегает прямого добавления конфиденциальной информации в файл журнала, что снижает риск несанкционированного доступа или воздействия.

Используя систему протоколирования и выбирая соответствующие уровни протоколирования, код, соответствующий требованиям, повышает безопасность конфиденциальной информации, протоколируя ее более контролируемым и безопасным образом. Это помогает защитить конфиденциальность конфиденциальных данных и снижает риск несанкционированного доступа или раскрытия информации через файлы журналов.



## Подделка запросов со стороны сервера (SSRF)

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
import java.net.URL
import scala.io.Source

def fetchURLContent(url: String): String = {
  val source = Source.fromURL(new URL(url))
  source.mkString
}
```

В коде, не соответствующем требованиям, функция fetchURLContent принимает URL в качестве входных данных и извлекает содержимое из этого URL с помощью метода Source.fromURL. Этот код уязвим для атак SSRF, поскольку он не проверяет должным образом или не ограничивает URL, к которым можно получить доступ. Злоумышленник может потенциально злоупотребить этой функциональностью для выполнения запросов к внутренним или даже внешним ресурсам, которые должны быть недоступны.






<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
import java.net.URL
import scala.io.Source

def fetchURLContent(url: String): String = {
  val validatedURL = validateURL(url)
  val source = Source.fromURL(new URL(validatedURL))
  source.mkString
}

def validateURL(url: String): String = {
  // Реализуйте логику проверки URL в соответствии с вашими требованиями
  // Убедитесь, что URL-адрес принадлежит доверенному домену или белому списку
  // При необходимости ограничьте доступ к внутренним ресурсам
  // Применить соответствующие правила фильтрации или проверки URL
  // Верните проверенный URL или выбросьте исключение, если он недействителен
  // Пример: Проверка, начинается ли URL с доверенного домена
  val trustedDomain = "https://example.com"
  if (!url.startsWith(trustedDomain)) {
    throw new IllegalArgumentException("Invalid or unauthorized URL")
  }
  url
}
```


В совместимом коде функция fetchURLContent включает дополнительный шаг для проверки входного URL перед доступом к его содержимому. Функция validateURL введена для выполнения проверки URL и применения любых необходимых ограничений или фильтрации. Она гарантирует, что обрабатываются только доверенные и авторизованные URL, снижая риск атак SSRF.

Ключевые улучшения в совместимом коде:

1. Проверка URL: В совместимом коде реализована функция validateURL для проверки входного URL на основе конкретных требований приложения. Она может включать такие проверки, как проверка домена URL по доверенному списку, применение правил "белого" или "черного" списка или ограничение доступа к внутренним ресурсам.
2. Ограничение доступа: Функция validateURL накладывает ограничения на URL, к которым можно получить доступ, гарантируя, что обрабатываются только авторизованные URL. Это помогает предотвратить атаки SSRF, ограничивая область разрешенных запросов.
3. Обработка исключений: Если в процессе проверки обнаруживается недействительный или неавторизованный URL, возникает исключение, указывающее на то, что URL недействителен или не разрешен. Правильная обработка исключений может помочь в выявлении и обработке потенциальных попыток SSRF.

Реализуя проверку URL и накладывая ограничения на URL, к которым можно обращаться, совместимый код снижает риск атак SSRF. Он обеспечивает дополнительный уровень защиты, гарантируя, что обрабатываются только доверенные и авторизованные URL-адреса, снижая вероятность доступа к конфиденциальным или непредусмотренным ресурсам.
