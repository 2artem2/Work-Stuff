---
layout: default
title: Ruby
parent: Rules
---

# Ruby
{: .no_toc }



## Оглавление
{: .no_toc .text-delta }

1. TOC
{:toc}

---




## Раскрытие конфиденциальной информации

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
def process_payment(user, amount)
  # Записывайте платежные данные, включая конфиденциальную информацию
  puts "Payment processed for user #{user.name} with amount #{amount}"
  # Обработать платеж
  # ...
end
```

Код, не соответствующий требованиям, напрямую записывает конфиденциальную информацию, такую как имя пользователя и сумма платежа, используя метод puts. Такая практика представляет собой угрозу безопасности, поскольку файлы журналов часто доступны нескольким пользователям, что увеличивает вероятность несанкционированного доступа к конфиденциальной информации. Злоумышленники могут использовать эту уязвимость для сбора данных о пользователе или финансовой информации.







<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
require 'logger'

def process_payment(user, amount)
 # Инициализируйте логгер с соответствующими настройками
  logger = Logger.new('payment.log')
  
  # Выведите в журнал сообщение, не содержащее конфиденциальной 
  logger.info("Payment processed for user with ID #{user.id}")
  
  # Обработать платеж
  # ...
end
```


Код, соответствующий требованиям, использует класс Logger из стандартной библиотеки Ruby для регистрации сообщений с соответствующими настройками. Конфиденциальная информация, такая как имя пользователя и сумма платежа, не включается непосредственно в сообщение журнала. Вместо этого в журнал записывается сообщение, содержащее нечувствительную информацию, например идентификатор пользователя.

Используя класс Logger, вы можете управлять расположением, форматом и правами доступа к файлу журнала. При необходимости можно настроить ротацию журнала и шифрование. Важно убедиться, что файлы журнала хранятся в безопасном месте с ограниченным доступом, что ограничивает доступ к конфиденциальной информации.

Не забудьте настроить параметры регистратора в соответствии с вашими специфическими требованиями, например, определить уровень журнала, параметры форматирования и стратегии ротации файлов журнала.

Соответствующий код помогает снизить риск раскрытия конфиденциальной информации через журналы, избегая прямого включения конфиденциальных данных в сообщения журналов и используя специальную систему ведения журналов, которая обеспечивает лучший контроль над хранением файлов журналов и доступом к ним.




## Вставка конфиденциальной информации в отправленные данные

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
def send_data(user, data)
  # Включите конфиденциальную информацию в отправляемые данные
  request_body = { user: user, data: data }
  HTTP.post('https://api.example.com/data', body: request_body.to_json)
end
```

Несоответствующий требованиям код включает конфиденциальную информацию, например объект пользователя, непосредственно в полезную нагрузку данных, которые отправляются во внешний API. Такая практика может привести к раскрытию конфиденциальной информации для потенциальных злоумышленников, если они перехватят или получат несанкционированный доступ к передаваемым данным.





<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
def send_data(user, data)
  # Исключите конфиденциальную информацию из отправляемых данных
  request_body = { data: data }
  HTTP.post('https://api.example.com/data', body: request_body.to_json)
end
```


Соответствующий код удаляет конфиденциальную информацию, например объект пользователя, из полезной нагрузки данных перед отправкой их во внешний API. Исключая конфиденциальную информацию из отправляемых данных, вы снижаете риск раскрытия конфиденциальных сведений нежелательным получателям.

Важно обеспечить безопасное обращение с конфиденциальной информацией и ее передачу только доверенным и уполномоченным лицам. Если необходимо, рассмотрите возможность шифрования конфиденциальных данных перед передачей, чтобы добавить дополнительный уровень защиты.

Следуя подходу, основанному на совместимом коде, вы отделяете конфиденциальную информацию от данных, отправляемых во внешние службы, снижая вероятность случайного раскрытия и уменьшая потенциальные риски безопасности.







## Подделка межсайтовых запросов (CSRF)

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
# Несоответствующий код
get '/transfer_funds' do
  amount = params[:amount]
  recipient = params[:recipient]

  # Логика перевода средств здесь
  # ...
end
```

В этом несовместимом коде не реализована защита от CSRF. Злоумышленник может создать вредоносную HTML-страницу, содержащую форму для перевода средств, и если пользователь аутентифицирован и посещает эту страницу, будучи одновременно авторизованным на уязвимом сайте, перевод средств может быть осуществлен без явного согласия пользователя.



Чтобы устранить эту уязвимость, необходимо реализовать защиту от CSRF. Вот пример совместимого кода, включающего защиту от CSRF:




<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
# Соответствующий код
enable :sessions

before do
  csrf_token = session[:csrf_token]
  unless params[:csrf_token] == csrf_token
    halt 403, 'CSRF token verification failed!'
  end
end

get '/transfer_funds' do
  amount = params[:amount]
  recipient = params[:recipient]

  # Логика перевода средств здесь
  # ...
end
```


В коде, соответствующем требованиям, строка enable :sessions включает обработку сессий в Sinatra, которая будет хранить уникальный идентификатор сессии в куках браузера пользователя. Этот идентификатор сессии будет связан с данными сессии пользователя на сервере.

Блок before выполняется перед каждым запросом и проверяет, совпадает ли отправленный в запросе CSRF-токен с хранящимся в сессии. Если токены не совпадают, возвращается ответ 403 Forbidden, указывающий на то, что проверка CSRF-токена не удалась.

Чтобы использовать эту защиту от CSRF, вам нужно сгенерировать и включить CSRF-токен в ваши HTML-формы. Например:







## Использование жесткого пароля

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
# Несоответствующий код
def login(username, password)
  if username == 'admin' && password == 'password123'
    puts 'Login successful'
  else
    puts 'Invalid credentials'
  end
end
```

В этом несоответствующем коде имя пользователя и пароль жестко закодированы непосредственно в коде. Это представляет собой риск для безопасности, поскольку любой человек, имеющий доступ к коду, может легко увидеть и потенциально злоупотребить жестко закодированными учетными данными. Если код находится в общем доступе или хранится в системе контроля версий, конфиденциальный пароль становится еще более уязвимым.



Чтобы решить эту проблему безопасности, важно избегать жесткого кодирования паролей в коде. Вот пример совместимого кода, который позволяет избежать использования жестко закодированных паролей:







<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
# Соответствующий код
def login(username, password)
  stored_password = retrieve_password_from_database(username)

  if stored_password && stored_password == password
    puts 'Login successful'
  else
    puts 'Invalid credentials'
  end
end
```

В коде, соответствующем требованиям, жестко заданный пароль заменяется вызовом функции retrieve_password_from_database(username). Эта функция извлекает пароль, связанный с заданным именем пользователя, из безопасного источника данных, например базы данных.


Безопасное хранение паролей и их динамическое извлечение при необходимости позволяет предотвратить риски, связанные с жестким кодированием паролей в коде. Важно убедиться, что механизм хранения паролей, например база данных, соответствует лучшим отраслевым практикам безопасности, таким как правильное хеширование и соление паролей.

Кроме того, стоит отметить, что в реальном сценарии обычно не используется оператор puts для индикации успешного входа в систему. Вместо этого вы, как правило, перенаправляете пользователя в аутентифицированную сессию или выполняете дальнейшие действия в зависимости от результата входа. Приведенный пример посвящен исключительно работе с паролями.








## Сломанный или рискованный криптоалгоритм

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
# Несоответствующий код
require 'openssl'

def encrypt_data(data, key)
  cipher = OpenSSL::Cipher.new('DES')
  cipher.encrypt
  cipher.key = key
  encrypted_data = cipher.update(data) + cipher.final
  encrypted_data
end
```


В этом несоответствующем коде для шифрования данных используется алгоритм Data Encryption Standard (DES). DES считается небезопасным и устаревшим, поскольку он имеет известные уязвимости и подвержен атакам методом перебора. Использование DES для шифрования может нарушить конфиденциальность и безопасность данных.

Чтобы решить эту проблему безопасности, важно использовать современные и безопасные криптографические алгоритмы. Вот пример совместимого кода, в котором используется безопасный алгоритм:







<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
# Соответствующий код
require 'openssl'

def encrypt_data(data, key)
  cipher = OpenSSL::Cipher.new('AES-256-CBC')
  cipher.encrypt
  cipher.key = key
  iv = cipher.random_iv
  encrypted_data = cipher.update(data) + cipher.final
  encrypted_data
end
```

В совместимом коде используется алгоритм Advanced Encryption Standard (AES) с размером ключа 256 бит и режимом Cipher Block Chaining (CBC). AES считается безопасным и широко используется в различных приложениях и отраслях.

Код генерирует случайный вектор инициализации (IV) с помощью cipher.random_iv и использует его в сочетании с ключом для шифрования данных. Включение случайного IV для каждой операции шифрования добавляет дополнительный уровень безопасности к процессу шифрования.

Важно следить за актуальными передовыми практиками в области криптографии и выбирать алгоритмы, которые считаются безопасными в соответствии с отраслевыми стандартами. Кроме того, необходимо обеспечить безопасное обращение с криптографическими ключами и следовать рекомендованным методам управления ключами, таким как правильное хранение и защита ключей от несанкционированного доступа.









## Недостаточная энтропия

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
# Несоответствующий код
def generate_password(length)
  charset = Array('A'..'Z') + Array('a'..'z') + Array('0'..'9')
  password = Array.new(length) { charset.sample }.join
  password
end
```


В этом несовместимом коде пароль генерируется с использованием ограниченного набора символов, состоящего только из прописных, строчных букв и цифр. Хотя такой подход может показаться разумным на первый взгляд, он не обладает достаточной энтропией, что делает сгенерированные пароли относительно слабыми.

Чтобы решить эту проблему безопасности, важно повысить энтропию генерируемых паролей. Вот пример совместимого кода, в котором используется более надежный подход:







<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
# Соответствующий код
require 'securerandom'

def generate_password(length)
  charset = Array('A'..'Z') + Array('a'..'z') + Array('0'..'9') + ['!', '@', '#', '$', '%', '^', '&', '*', '(', ')']
  password = Array.new(length) { charset.sample }.join
  password
end

def generate_secure_password(length)
  password = SecureRandom.urlsafe_base64(length)
  password
end
```

В совместимом коде предусмотрены две функции для генерации паролей. Первая функция, generate_password, улучшает энтропию, расширяя набор символов, чтобы включить дополнительные специальные символы. Это увеличивает количество возможных комбинаций и делает генерируемые пароли более надежными.

Вторая функция, generate_secure_password, использует модуль Ruby SecureRandom для генерации безопасного случайного пароля с помощью криптографически сильного генератора случайных чисел. Метод urlsafe_base64 гарантирует, что сгенерированный пароль будет безопасен для URL, благодаря использованию набора символов, специально разработанного для этих целей.

Важно отметить, что выбор длины пароля и набора символов должен быть тщательно продуман, исходя из конкретных требований и политик безопасности вашего приложения. Кроме того, поощрение пользователей к выбору более длинных, уникальных и сложных паролей очень важно для поддержания надежной системы безопасности.







## Межсайтовый скриптинг (XSS)

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
# Несоответствующий код
get '/search' do
  query = params[:query]
  "<h1>Search Results for #{query}</h1>"
end
```

В этом несоответствующем коде заданный пользователем параметр запроса напрямую встраивается в HTML-ответ без какой-либо дезинфекции или проверки. Это делает приложение уязвимым для XSS-атак. Злоумышленник может воспользоваться этой уязвимостью, внедрив в параметр запроса вредоносный код, который будет выполнен при просмотре страницы с результатами поиска другими пользователями.

Чтобы решить эту проблему безопасности, важно правильно санировать пользовательский ввод для предотвращения XSS-атак. Вот пример совместимого кода, который устраняет XSS-уязвимость:








<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
# Соответствующий код
require 'rack/utils'

get '/search' do
  query = params[:query]
  sanitized_query = Rack::Utils.escape_html(query)
  "<h1>Search Results for #{sanitized_query}</h1>"
end
```


В совместимом коде метод Rack::Utils.escape_html используется для экранирования любых HTML-символов в параметре запроса. Это гарантирует, что пользовательский ввод будет рассматриваться как обычный текст и предотвратит выполнение в браузере кода HTML или JavaScript.

Правильная санация пользовательского ввода и экранирование специальных символов позволяют предотвратить XSS-атаки и защитить ваше приложение и пользователей от потенциальных рисков безопасности. Важно обеззараживать вводимые пользователем данные всякий раз, когда они отображаются в HTML или других контекстах, которые могут интерпретировать их как исполняемый код.






## SQL-инъекция

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
# Несоответствующий код
get '/search' do
  query = params[:query]
  result = DB.execute("SELECT * FROM products WHERE name = '#{query}'")
  # Обработка и возврат результатов поиска
end
```

В этом несовместимом коде параметр запроса, заданный пользователем, напрямую интерполируется в строку SQL-запроса. Это может привести к уязвимости SQL Injection, если злоумышленник манипулирует параметром запроса для выполнения вредоносных SQL-запросов. Например, злоумышленник может ввести ' OR '1'='1' -- в качестве значения запроса, в результате чего запрос превратится в SELECT * FROM products WHERE name = '' OR '1'='1' --', минуя всю предполагаемую логику запроса и потенциально раскрывая конфиденциальные данные.

Для защиты от уязвимостей SQL Injection важно использовать параметризованные запросы или подготовленные операторы. Вот пример совместимого кода, который защищает от SQL Injection:





<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
# Соответствующий код
get '/search' do
  query = params[:query]
  result = DB.execute("SELECT * FROM products WHERE name = ?", query)
  # Обработка и возврат результатов поиска
end
```

В коде, соответствующем требованиям, вместо прямой интерполяции пользовательского ввода в строку SQL-запроса используется параметризованный запрос. Для обозначения параметра запроса используется заполнитель ? Фактическое значение запроса передается отдельно в функцию запроса к базе данных, что гарантирует, что оно будет рассматриваться как параметр, а не как исполняемый код SQL.

Использование параметризованных запросов или подготовленных операторов позволяет отделить логику SQL от пользовательского ввода, эффективно предотвращая атаки SQL Injection. Движок базы данных обрабатывает правильное экранирование и цитирование значений параметров, устраняя риск возникновения уязвимостей SQL Injection.

Очень важно использовать этот подход, когда пользовательский ввод включается в SQL-запросы, чтобы обеспечить безопасность и целостность взаимодействия вашего приложения с базой данных.






## Внешнее управление именем или путем файла

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
# Несоответствующий код
get '/download' do
  filename = params[:filename]
  file_path = "/path/to/files/#{filename}"
  send_file(file_path, disposition: 'attachment')
end
```


В этом несовместимом коде параметр filename напрямую используется для построения пути к файлу без какой-либо проверки или санации. Это может привести к уязвимостям безопасности, например, к атакам с обходом каталога, когда злоумышленник может манипулировать параметром filename для доступа к файлам за пределами предполагаемого каталога.


Чтобы решить эту проблему безопасности, важно проверять и санировать имя файла или путь к нему перед использованием. Вот пример совместимого кода, который устраняет уязвимость External Control of File Name or Path:







<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
# Соответствующий код
get '/download' do
  filename = params[:filename]
  sanitized_filename = File.basename(filename)
  file_path = File.join("/path/to/files/", sanitized_filename)

  if File.exist?(file_path) && File.file?(file_path)
    send_file(file_path, disposition: 'attachment')
  else
    halt 404, 'File not found'
  end
end
```

В совместимом коде метод File.basename используется для извлечения базового имени файла из заданного пользователем параметра filename. Это устраняет любые компоненты обхода каталога и предотвращает несанкционированный доступ к файлу. Затем используется метод File.join для построения полного пути к файлу путем объединения дезинфицированного имени файла с базовым путем к файлу.

Перед отправкой файла код проверяет, существует ли файл и является ли он обычным файлом, используя File.exist? и File.file?. Если файл не найден или не является действительным файлом, возвращается ответ 404, что предотвращает несанкционированную загрузку файла.

Проверяя и санируя имя файла или путь к нему перед использованием, вы можете снизить риск внешнего контроля над именами файлов или путями к ним и предотвратить несанкционированный доступ к конфиденциальным файлам на сервере.







## Формирование сообщения об ошибке, содержащего конфиденциальную информацию

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
# Несоответствующий код
get '/user/:id' do
  user_id = params[:id]
  user = User.find(user_id)

  if user.nil?
    error_message = "User with ID #{user_id} not found"
    raise StandardError, error_message
  end

  # Обработка и возврат пользовательских данных
end
```


В этом несоответствующем коде, когда запрашиваемый идентификатор пользователя не найден, генерируется сообщение об ошибке, содержащее конфиденциальную информацию (идентификатор пользователя), и передается в виде исключения. Это может привести к раскрытию конфиденциальной информации злоумышленникам или непреднамеренным пользователям, что позволит им собрать информацию о системе или конкретных пользователях.

Чтобы решить эту проблему безопасности, важно избегать раскрытия конфиденциальной информации в сообщениях об ошибках. Вот пример совместимого кода, который позволяет избежать раскрытия конфиденциальной информации:






<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
# Соответствующий код
get '/user/:id' do
  user_id = params[:id]
  user = User.find(user_id)

  if user.nil?
    error_message = "User not found"
    raise StandardError, error_message
  end

  # Обработка и возврат пользовательских данных
end
```

В коде, соответствующем требованиям, сообщение об ошибке обобщено и содержит минимум информации, избегая каких-либо конкретных деталей, которые могут раскрыть конфиденциальную информацию. Вместо указания идентификатора пользователя в сообщении об ошибке используется более общее сообщение о том, что пользователь не найден.

Избегая включения конфиденциальной информации в сообщения об ошибках, вы снижаете риск непреднамеренного раскрытия конфиденциальных данных потенциальным злоумышленникам или нежелательным пользователям. Важно тщательно продумать информацию, сообщаемую в сообщениях об ошибках, и убедиться, что они не раскрывают конфиденциальную или личную информацию.







## Незащищенное хранение учетных данных

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
# Несоответствующий код
API_KEY = 'my_api_key'
DB_PASSWORD = 'my_db_password'
```

В этом несоответствующем коде учетные данные (ключ API и пароль базы данных) напрямую вписаны в исходный код. Хранение учетных данных таким образом представляет собой значительный риск безопасности, поскольку любой человек, имеющий доступ к исходному коду, может легко просмотреть и использовать эти конфиденциальные учетные данные не по назначению. Если код находится в общем доступе или хранится в системе контроля версий, учетные данные становятся еще более уязвимыми.

Чтобы решить эту проблему безопасности, важно не хранить учетные данные в незащищенных и легкодоступных местах. Вот пример совместимого кода, который улучшает хранение учетных данных:






<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
# Соответствующий код
require 'dotenv'

Dotenv.load('.env')

API_KEY = ENV['API_KEY']
DB_PASSWORD = ENV['DB_PASSWORD']
```

В совместимом коде мы используем гем dotenv для загрузки переменных окружения из файла .env. Файл .env не контролируется по версиям и обычно хранится отдельно от репозитория исходного кода. Учетные данные хранятся как переменные окружения в файле .env.

Загрузка учетных данных из переменных окружения позволяет хранить конфиденциальную информацию отдельно от исходного кода и обеспечивает дополнительный уровень защиты. Переменные среды могут быть установлены в среде развертывания или загружены из безопасного файла конфигурации, специфичного для среды развертывания, например переменные среды сервера или служба управления секретами поставщика облачных услуг.

Убедитесь, что вы следуете безопасным методам управления переменными среды, например ограничиваете доступ к файлу .env и обеспечиваете конфиденциальность и шифрование конфиденциальных учетных данных. Кроме того, регулярно проверяйте и меняйте учетные данные для поддержания безопасности.




## Trust Boundary Violation

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
# Несоответствующий код
def process_user_input(user_input)
  if user_input.admin?
    grant_admin_privileges()
  end

  # Обработка пользовательского ввода
end
```

В этом несоответствующем коде функция process_user_input принимает user_input в качестве параметра и проверяет, является ли пользователь администратором, используя метод admin? Если установлено, что пользователь является администратором, функция предоставляет ему права администратора без каких-либо дополнительных проверок достоверности или авторизации. Это нарушает границу доверия, поскольку предполагается, что метод admin? является безопасным и надежным способом определения привилегий пользователя.

Чтобы решить эту проблему безопасности, важно обеспечить надлежащую проверку и авторизацию пользовательских привилегий. Вот пример совместимого кода, который позволяет избежать нарушения границ доверия:





<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
# Соответствующий код
def process_user_input(user_input, user_role)
  if user_role == 'admin'
    grant_admin_privileges()
  end

  # Обработка пользовательского ввода
end
```


В совместимом коде функция process_user_input теперь принимает дополнительный параметр, user_role, который явно указывает на роль или уровень привилегий пользователя. Вместо того чтобы полагаться исключительно на метод или свойство объекта user_input, функция теперь полагается на параметр user_role, чтобы определить, следует ли предоставить пользователю привилегии администратора.

Передавая роль или уровень привилегий пользователя в качестве отдельного параметра, вы устанавливаете четкую границу доверия и не делаете предположений о безопасности или надежности конкретных свойств или методов. Это позволяет проводить более контролируемые и явные проверки авторизации на основе достоверной информации.

Помните, что проверка и авторизация привилегий пользователя всегда должны выполняться на стороне сервера, даже если аналогичные проверки выполняются на стороне клиента. Проверки на стороне клиента можно обойти или манипулировать ими, поэтому проверка на стороне сервера имеет решающее значение для поддержания безопасных границ доверия и защиты конфиденциальной функциональности или данных.







## Недостаточно защищенные учетные данные

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
# Несоответствующий код
API_KEY = 'my_api_key'
DB_PASSWORD = 'my_db_password'

# Код, использующий ключ API и пароль базы данных
```

В этом несоответствующем коде учетные данные (ключ API и пароль базы данных) напрямую вписаны в исходный код в виде открытого текста. Хранение учетных данных таким образом представляет собой значительный риск для безопасности, поскольку любой человек, имеющий доступ к исходному коду, может легко просмотреть и использовать эти конфиденциальные данные не по назначению.

Чтобы решить эту проблему безопасности, очень важно защитить учетные данные с помощью соответствующего шифрования или безопасных механизмов хранения. Вот пример совместимого кода, который улучшает защиту учетных данных:





<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
# Соответствующий код
require 'openssl'
require 'base64'

def encrypt_credentials(plaintext)
  cipher = OpenSSL::Cipher.new('AES-256-CBC')
  cipher.encrypt
  cipher.key = ENV['ENCRYPTION_KEY']
  encrypted = cipher.update(plaintext) + cipher.final
  Base64.encode64(encrypted)
end

API_KEY = encrypt_credentials('my_api_key')
DB_PASSWORD = encrypt_credentials('my_db_password')

# Код, использующий зашифрованные учетные данные
```


В совместимом коде мы используем библиотеку OpenSSL для шифрования учетных данных с помощью алгоритма шифрования AES-256-CBC. Ключ шифрования загружается из переменной окружения (ENV['ENCRYPTION_KEY']), которая должна храниться в безопасном месте, а не непосредственно в исходном коде.

Шифруя учетные данные, мы добавляем дополнительный уровень защиты. Даже если злоумышленник получит доступ к исходному коду, он увидит только зашифрованные версии учетных данных, что значительно усложнит ему задачу по использованию конфиденциальной информации.

Важно отметить, что совместимый код представляет собой лишь пример шифрования учетных данных. Фактическая реализация может отличаться в зависимости от конкретных требований и методов обеспечения безопасности вашего приложения. Кроме того, убедитесь, что вы следуете безопасным методам управления ключами шифрования, например, надежно храните их и периодически меняйте.

Не забывайте защищать конфиденциальные учетные данные в состоянии покоя и при передаче, чтобы обеспечить безопасность и целостность данных и систем вашего приложения.








## Ограничение ссылки на внешние сущности XML

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
# Несоответствующий код
require 'nokogiri'

xml_data = "<user><name>John Doe</name><credit_card>&xxe;</credit_card></user>"
doc = Nokogiri::XML(xml_data)

# Обработка XML-документа
```

В этом несоответствующем коде XML-документ, содержащий имя пользователя и элемент кредитной карты (<credit_card>), разбирается с помощью библиотеки Nokogiri. Значение элемента <credit_card> определено как &xxe;, что является ссылкой на сущность, которая потенциально может вызвать XXE-атаку, если парсер XML не настроен должным образом.

Чтобы решить эту проблему безопасности, важно правильно ограничить ссылки на внешние сущности XML. Вот пример совместимого кода, который снижает риск XXE-атак:






<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
# Соответствующий код
require 'nokogiri'

xml_data = "<user><name>John Doe</name><credit_card>&amp;xxe;</credit_card></user>"
doc = Nokogiri::XML(xml_data) do |config|
  config.nonet # Отключить доступ к сети
  config.noblanks # Игнорировать узлы с пробелами
  config.noent # Отключить расширение сущностей
end

# Обработка XML-документа
```


В совместимом коде XML-данные модифицируются, чтобы правильно экранировать символ & в ссылке на сущность как &amp;. Кроме того, при разборе XML-документа с помощью Nokogiri предусмотрен блок для настройки параметров парсера. Устанавливаются следующие параметры:

* config.nonet отключает доступ к сети, не позволяя парсеру XML делать внешние сетевые запросы.
* config.noblanks игнорирует узлы с пробелами, снижая риск XXE-атак с помощью методов эксплуатации, основанных на пробелах.
* config.noent отключает расширение сущностей, не позволяя парсеру XML разрешать и расширять внешние сущности.


Правильно настроив парсер XML и экранирование ссылок на сущности, вы сможете эффективно ограничить ссылки на внешние сущности XML и снизить риск XXE-атак. Важно проанализировать и настроить параметры парсера в соответствии с вашими конкретными требованиями и быть в курсе последних передовых методов обработки XML и обеспечения безопасности.




## Уязвимые и устаревшие компоненты


<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
# Несоответствующий код
require 'sinatra'

get '/hello' do
  "Hello, World!"
end
```

В этом несоответствующем коде приложение использует фреймворк Sinatra без учета версии и потенциальных уязвимостей самого фреймворка. В этом коде не учитывается тот факт, что старые версии Sinatra могут содержать уязвимости в системе безопасности или устаревшие зависимости, что может подвергнуть приложение потенциальным атакам.

Чтобы решить эту проблему безопасности, важно регулярно обновлять и использовать в приложении безопасные компоненты. Вот пример совместимого кода, который решает проблему использования уязвимых и устаревших компонентов:







<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
# Соответствующий код
require 'sinatra'

get '/hello' do
  "Hello, World!"
end
```

В совместимом коде используется тот же фреймворк Sinatra, но основное внимание уделяется тому, чтобы фреймворк и его зависимости поддерживались в актуальном состоянии. Это включает в себя регулярный мониторинг обновлений безопасности и их применение, как только они становятся доступными. Также очень важно быть в курсе всех уязвимостей и рекомендаций по безопасности, связанных с фреймворком или его зависимостями.

Проактивное обновление и управление компонентами приложения снижает риск использования устаревшего и уязвимого программного обеспечения. Это поможет защитить ваше приложение от известных уязвимостей безопасности и гарантирует, что вы используете последние исправления и улучшения безопасности.

Не забывайте следовать лучшим практикам управления зависимостями, включая регулярную проверку обновлений, использование средств сканирования уязвимостей и ведение актуального реестра компонентов вашего приложения. Кроме того, подпишитесь на списки рассылки по безопасности или на уведомления, относящиеся к используемым компонентам, чтобы быть в курсе всех потенциальных проблем безопасности.






## Неправильная проверка сертификата с несоответствием хоста

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
# Несоответствующий код
require 'net/http'

def make_secure_request(url)
  uri = URI.parse(url)
  http = Net::HTTP.new(uri.host, uri.port)
  http.use_ssl = true
  response = http.get(uri.request_uri)
  response.body
end

url = 'https://example.com'
response = make_secure_request(url)
puts response
```

В этом несоответствующем коде выполняется безопасный запрос к example.com с помощью Net::HTTP с включенным SSL. Однако код не выполняет надлежащую проверку сертификата сервера на несоответствие хосту. Это означает, что код примет любой действительный сертификат, даже если он не соответствует ожидаемому хосту (в данном случае example.com). Это может привести к атакам типа "человек посередине" или подключениям к вредоносным серверам.

Для решения этой проблемы безопасности очень важно выполнить правильную проверку сертификата сервера и убедиться, что он соответствует ожидаемому хосту. Вот пример совместимого кода, который улучшает проверку сертификата:







<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
# Соответствующий код
require 'net/http'
require 'openssl'

def make_secure_request(url)
  uri = URI.parse(url)
  http = Net::HTTP.new(uri.host, uri.port)
  http.use_ssl = true
  http.verify_mode = OpenSSL::SSL::VERIFY_PEER
  http.ca_file = '/path/to/certificate.crt' # Укажите путь к сертификату доверенного ЦС.
  response = http.get(uri.request_uri)
  response.body
end

url = 'https://example.com'
response = make_secure_request(url)
puts response
```


В совместимом коде для опции verify_mode установлено значение OpenSSL::SSL::VERIFY_PEER, чтобы обеспечить надлежащую проверку сертификата. Кроме того, параметр ca_file используется для указания пути к сертификату доверенного ЦС. Этот сертификат ЦС будет использоваться для проверки сертификата сервера и убедиться, что он выдан доверенным центром и соответствует ожидаемому хосту.


Убедитесь, что указан правильный путь к сертификату доверенного центра сертификации, который может правильно проверить сертификат сервера. Для этого можно получить сертификат ЦС из надежного источника или воспользоваться пакетом сертификатов, предоставляемым операционной системой или системой безопасности.

Выполнив правильную проверку сертификата сервера с помощью сопоставления хостов, вы сможете обеспечить создание безопасных соединений только с доверенными серверами и снизить риск атак типа "человек посередине" или соединений с вредоносными хостами.








## Неправильная аутентификация

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
# Несоответствующий код
def authenticate(username, password)
  if username == 'admin' && password == 'secret'
    puts 'Authentication successful'
  else
    puts 'Authentication failed'
  end
end

# Использование
authenticate('admin', 'guess')  # Попытка аутентификации, не соответствующая требованиям
```

В этом несоответствующем коде функция authenticate принимает в качестве аргументов имя пользователя и пароль и выполняет простое сравнение строк, чтобы проверить, совпадают ли предоставленные учетные данные с жестко закодированными значениями. Такой подход небезопасен, поскольку в нем не реализованы надлежащие механизмы аутентификации, такие как выделение, хэширование или шифрование паролей, и используются жестко закодированные учетные данные.

Чтобы решить эту проблему безопасности, важно внедрить надлежащие механизмы аутентификации, которые следуют безопасным практикам. Вот пример совместимого кода, который улучшает процесс аутентификации:








<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
# Соответствующий код
require 'bcrypt'

def authenticate(username, password)
  hashed_password = get_hashed_password(username)
  if BCrypt::Password.new(hashed_password) == password
    puts 'Authentication successful'
  else
    puts 'Authentication failed'
  end
end

def get_hashed_password(username)
  # Получите хэшированный пароль, связанный с именем пользователя,
  # из безопасного хранилища (например, базы данных).
  # Верните хэшированный пароль
end

# Использование
authenticate('admin', 'guess')  # Соответствующая попытка аутентификации
```


В совместимом коде процесс аутентификации улучшен за счет использования гема bcrypt для безопасного хэширования и проверки паролей. Функция get_hashed_password извлекает хэшированный пароль, связанный с указанным именем пользователя, из безопасного хранилища, например базы данных. Затем код использует BCrypt::Password.new для создания нового объекта BCrypt::Password из хэшированного пароля и сравнивает его с предоставленным паролем с помощью оператора ==. Это гарантирует, что пароль правильно хэширован и безопасно сравнен.


Важно отметить, что приведенный код является лишь примером того, как можно улучшить процесс аутентификации. Реальная реализация может отличаться в зависимости от конкретных требований и методов обеспечения безопасности вашего приложения. Кроме того, рассмотрите возможность применения других мер безопасности, таких как блокировка учетных записей, строгая политика паролей и механизмы безопасного сброса пароля, чтобы еще больше усовершенствовать процесс аутентификации.

Не забывайте следовать отраслевым стандартам безопасной аутентификации, например, использовать надежные алгоритмы хеширования, надежно хранить пароли, защищаться от атак методом перебора, а также быть в курсе последних уязвимостей и лучших практик безопасности.








## Фиксация сеанса

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
# Несоответствующий код
require 'sinatra'

get '/login' do
  session[:user_id] = params[:user_id]
  redirect '/dashboard'
end

get '/dashboard' do
  # Доступ к данным пользователя на основе session[:user_id].
end
```

В этом коде, не соответствующем требованиям, маршрут /login устанавливает параметр user_id как значение переменной session[:user_id]. Проблема в том, что этот код не генерирует новый идентификатор сессии при успешном входе в систему. Злоумышленник может потенциально зафиксировать сессию, получив действительный идентификатор сессии, например, убедив пользователя щелкнуть по специально созданной ссылке с заранее определенным идентификатором сессии.

Для решения этой проблемы безопасности очень важно генерировать новый идентификатор сессии при успешном входе в систему. Вот пример совместимого кода, который устраняет уязвимость фиксации сеанса:







<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
# Соответствующий код
require 'sinatra'
require 'securerandom'

enable :sessions

get '/login' do
  session.clear # Очистите существующие данные сеанса
  session[:user_id] = params[:user_id]
  session[:session_id] = SecureRandom.uuid # Создайте новый идентификатор сессии
  redirect '/dashboard'
end

get '/dashboard' do
  # Доступ к данным пользователя на основе session[:user_id].
end
```


В совместимом коде маршрут /login теперь включает session.clear, чтобы убедиться, что все существующие данные сессии очищены перед установкой user_id и генерацией нового идентификатора сессии с помощью SecureRandom.uuid. Это помогает предотвратить фиксацию сеанса, отбрасывая все существующие данные сеанса и создавая новый сеанс при успешном входе в систему.

Кроме того, оператор enable :sessions используется для включения управления сессиями в Sinatra.

Генерируя новый идентификатор сессии при входе в систему, вы снижаете риск атак с фиксацией сессии. Это гарантирует, что каждому пользователю будет присвоен уникальный идентификатор сессии, что не позволит злоумышленнику зафиксировать определенный идентификатор сессии и получить несанкционированный доступ к сессии пользователя.

Не забывайте применять безопасные методы управления сеансами, такие как использование надежных идентификаторов сеансов, включение защищенных файлов cookie, установка соответствующего времени истечения сеанса и проверка данных сеанса при последующих запросах. Регулярное тестирование и аудит реализации управления сеансами также очень важны для выявления и устранения любых потенциальных уязвимостей.






## Включение функциональности из недоверенного управления

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
# Несоответствующий код
source_code = params[:source_code]
eval(source_code)
```

В этом несовместимом коде параметр source_code получен из недоверенного источника, например из пользовательского ввода или внешнего файла. Затем код использует функцию eval для выполнения содержимого source_code. Такой подход крайне небезопасен, поскольку позволяет выполнить произвольный код, что может привести к серьезным уязвимостям в системе безопасности, включая удаленное выполнение кода, раскрытие информации и несанкционированный доступ.

Чтобы решить эту проблему безопасности, важно избегать прямого выполнения недоверенного кода с помощью функций типа eval. Вместо этого следует использовать более безопасные альтернативы, обеспечивающие контролируемую среду выполнения. Вот пример совместимого кода, который смягчает включение функциональности из недоверенного источника управления:







<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
# Соответствующий код
require 'sandbox'

source_code = params[:source_code]

sandbox = Sandbox.safe
sandbox.eval(source_code)
```


В совместимом коде объект песочницы создается с помощью гема Sandbox. Этот гем обеспечивает контролируемую среду для выполнения недоверенного кода, ограничивая масштаб потенциального ущерба. На объекте песочницы вызывается метод eval, который безопасно оценивает исходный_код в контролируемой среде.


Используя механизм "песочницы" или изолированную среду, вы можете ограничить выполнение недоверенного кода и предотвратить его доступ к важным ресурсам или внедрение уязвимостей безопасности в ваше приложение. Важно тщательно изучить и понять возможности и ограничения выбранного вами решения для создания "песочницы", чтобы убедиться, что оно соответствует вашим требованиям безопасности.

Не забывайте проявлять осторожность при внедрении кода из ненадежных источников. Проверяйте и обеззараживайте вводимые данные, ограничивайте доступ к чувствительной функциональности и придерживайтесь принципа наименьших привилегий. Регулярно обновляйте и исправляйте приложение и его зависимости для защиты от известных уязвимостей.






## Загрузка кода без проверки целостности

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
# Несоответствующий код
require 'open-uri'

file_url = 'http://example.com/malicious_code.rb'
file_content = open(file_url).read

# Обработка содержимого загруженного файла file_content
```

В этом несовместимом коде библиотека open-uri используется для загрузки файла с указанного URL. Однако код не выполняет никакой проверки целостности загруженного файла. Это означает, что содержимое файла может быть изменено во время транспортировки или злоумышленником, что может привести к появлению уязвимостей безопасности или выполнению несанкционированного кода в системе.

Для решения этой проблемы безопасности очень важно выполнять проверку целостности загружаемых файлов, чтобы гарантировать их подлинность и целостность. Вот пример совместимого кода, включающего проверку целостности:






<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
# Соответствующий код
require 'open-uri'
require 'digest'

file_url = 'http://example.com/malicious_code.rb'
file_content = open(file_url).read

expected_hash = '5f4dcc3b5aa765d61d8327deb882cf99' # Пример ожидаемого хэша MD5

if Digest::MD5.hexdigest(file_content) == expected_hash
  # Проверка целостности файла пройдена
  # Обработайте содержимое_скачанного_файла
else
  # Проверка целостности файла не прошла
  # Обработать ошибку или отклонить загруженный файл
end
```


В совместимом коде модуль Digest используется для вычисления MD5-хэша содержимого загруженного файла с помощью Digest::MD5.hexdigest. Затем вычисленный хэш сравнивается с ожидаемым значением хэша. Если хэши совпадают, проверка целостности пройдена, и код переходит к обработке содержимого загруженного файла. Если хэши не совпадают, проверка целостности проваливается, и может быть реализована соответствующая обработка ошибок или отказ от загрузки файла.


Важно отметить, что MD5 используется в этом примере для простоты, но на практике рекомендуется использовать более мощные хэш-алгоритмы, такие как SHA-256 или SHA-3. Кроме того, рассмотрите возможность внедрения механизмов безопасной загрузки, таких как использование HTTPS для безопасной передачи, проверка подлинности источника файла и обеспечение надежности и безопасности сервера, на котором размещен файл.

Проверка целостности загружаемых файлов позволяет проверить их подлинность и защитить от несанкционированных модификаций или подделок. Это помогает убедиться, что выполняемый код или обрабатываемые файлы получены из надежных и неизмененных источников, что снижает риск возникновения уязвимостей в системе безопасности или выполнения вредоносного кода.







## Десериализация недоверенных данных

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
# Несоответствующий код
data = params[:serialized_data]
object = Marshal.load(data)

# Обработка десериализованного объекта
```

В этом несоответствующем коде метод Marshal.load используется для десериализации данных, полученных из параметра serialized_data. Проблема этого кода заключается в том, что он не проверяет и не санирует десериализованные данные, позволяя потенциально вредоносным или недоверенным данным выполняться в качестве кода. Это может привести к серьезным уязвимостям безопасности, таким как удаленное выполнение кода или создание произвольного объекта.



Чтобы решить эту проблему безопасности, очень важно внедрить надлежащую проверку и санитарную обработку десериализованных данных. Вот пример совместимого кода, который защищает от десериализации недоверенных данных:






<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
# Соответствующий код
data = params[:serialized_data]
object = nil

begin
  object = YAML.safe_load(data, [Symbol])
rescue Psych::Exception => e
  # Обработка ошибки десериализации
  puts "Deserialization error: #{e.message}"
end

# Обработайте десериализованный объект, если он был успешно загружен
if object
  # Обработать десериализованный объект
else
  # Обработать ошибку или отклонить десериализованные данные
end
```


В совместимом коде для десериализации данных вместо Marshal.load используется метод YAML.safe_load. Метод safe_load обеспечивает более безопасную альтернативу, позволяя указывать разрешенные классы и символы во время десериализации. В этом примере разрешенный класс ограничен Symbol с использованием [Symbol] в качестве второго аргумента.

Кроме того, код включает обработку ошибок для перехвата любых ошибок десериализации, которые могут возникнуть, например, вызванных методом safe_load. Это позволяет правильно обрабатывать ошибки десериализации и предотвращать потенциальные проблемы, такие как неожиданные сбои в работе приложения или раскрытие информации.

Важно отметить, что метод safe_load - это лишь один из примеров более безопасного подхода к десериализации с использованием библиотеки YAML. В зависимости от ваших конкретных потребностей и требований, вы можете выбрать другие механизмы десериализации или библиотеки, которые предлагают аналогичные функции безопасности.

Реализовав надлежащую проверку и санацию десериализованных данных, вы сможете снизить риск выполнения недоверенного кода или вредоносных полезных нагрузок. Это позволяет гарантировать, что десериализованные данные безопасны и содержат только ожидаемые и разрешенные объекты, что снижает риск возникновения уязвимостей безопасности или несанкционированных действий.







## Недостаточное ведение журнала

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
# Несоответствующий код
def transfer_funds(sender, recipient, amount)
  if sender.balance >= amount
    sender.balance -= amount
    recipient.balance += amount
    puts "Funds transferred successfully."
  else
    puts "Insufficient funds."
  end
end
```

В этом коде, не соответствующем требованиям, функция transfer_funds выполняет операцию перевода средств между отправителем и получателем. Однако код только регистрирует сообщение об успехе или неудаче в консоли с помощью puts. Такой подход обеспечивает недостаточное протоколирование, поскольку не фиксирует важные детали и события, которые могут помочь в устранении неполадок, аудите или расследовании инцидентов безопасности.

Чтобы решить эту проблему безопасности, очень важно внедрить достаточное и значимое протоколирование в ваше приложение. Вот пример совместимого кода, который улучшает ведение журнала:







<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
# Соответствующий код
require 'logger'

logger = Logger.new('application.log')

def transfer_funds(sender, recipient, amount)
  if sender.balance >= amount
    sender.balance -= amount
    recipient.balance += amount
    logger.info("Funds transferred: $#{amount} from #{sender.name} to #{recipient.name}")
  else
    logger.warn("Insufficient funds for transfer: $#{amount} from #{sender.name} to #{recipient.name}")
  end
end
```


В совместимом коде класс Logger из стандартной библиотеки Ruby используется для создания экземпляра логгера, который записывает сообщения в файл (в данном примере application.log). Метод info используется для регистрации успешного перевода средств с соответствующими деталями, такими как сумма перевода, имя отправителя и имя получателя. В случае нехватки средств метод warn используется для регистрации предупреждающего сообщения с аналогичными данными.

Используя правильный механизм протоколирования, такой как Logger, вы можете фиксировать важные события, ошибки и информацию в вашем приложении. Журнал должен включать в себя такие важные данные, как временные метки, идентификаторы пользователей или запросов, выполняемые действия, входные значения и результаты. Это поможет в устранении неполадок, мониторинге поведения приложения, обнаружении подозрительных действий и расследовании инцидентов безопасности.

Кроме того, обеспечьте защиту и надежное хранение журналов, чтобы предотвратить несанкционированный доступ или фальсификацию. Регулярно просматривайте и анализируйте журналы для выявления аномалий, потенциальных угроз безопасности или необычных моделей поведения.

Не забывайте соблюдать правила безопасного ведения журналов, например не включать в журналы конфиденциальную информацию, например пароли или личные данные, устанавливать соответствующие уровни журналов и использовать систему управления журналами для централизованного хранения и эффективного анализа журналов.




## Improper Output Neutralization for Logs

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
# Несоответствующий код
logger = Logger.new('application.log')

def log_user_activity(user_id, activity)
  logger.info("User #{user_id} performed activity: #{activity}")
end
```

В этом несовместимом коде функция log_user_activity регистрирует активность пользователя, напрямую интерполируя параметры user_id и activity в сообщение журнала. Такой подход может привести к уязвимости инъекции в журнал, если параметры содержат специальные символы или вредоносный ввод. Злоумышленник может использовать эту уязвимость для изменения записей журнала или введения вредоносного содержимого в файл журнала.

Для решения этой проблемы безопасности очень важно правильно нейтрализовать вывод при включении пользовательских данных в сообщения журнала. Вот пример совместимого кода, в котором применяется нейтрализация вывода:







<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
# Соответствующий код
logger = Logger.new('application.log')

def log_user_activity(user_id, activity)
  sanitized_user_id = sanitize_output(user_id)
  sanitized_activity = sanitize_output(activity)

  logger.info("User #{sanitized_user_id} performed activity: #{sanitized_activity}")
end

def sanitize_output(input)
  # Реализуйте здесь логику нейтрализации вывода.
  # Например, удалить или скрыть специальные символы,
  # которые могут быть использованы для инъекции в журнал
  sanitized_input = input.gsub(/[<>]/, '')

  # Верните обработанный ввод
  sanitized_input
end
```


В совместимом коде функция log_user_activity применяет метод sanitize_output к параметрам user_id и activity перед включением их в сообщение журнала. Метод sanitize_output реализует логику нейтрализации вывода для удаления или экранирования специальных символов, которые могут быть использованы для инъекции в журнал. В этом примере метод gsub используется для удаления угловых скобок (< и >) из входных данных.

Важно реализовать логику нейтрализации вывода в соответствии с требованиями вашего приложения и потенциальными угрозами, которые вы хотите предотвратить. Рассмотрите возможность использования безопасных методов кодирования, таких как кодирование или экранирование специальных символов, проверка и ограничение входных значений, а также соблюдение соответствующих форматов вывода (например, JSON, CSV) для структурированных журналов.

Правильная нейтрализация вывода при регистрации пользовательских данных позволяет предотвратить уязвимости, связанные с инъекциями в журнал, и обеспечить целостность и безопасность записей в журнале. Регулярно проверяйте и анализируйте процессы создания и обработки журналов, чтобы выявить и устранить любые потенциальные уязвимости или неправильные конфигурации.








## Упущение информации, имеющей отношение к безопасности

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
# Несоответствующий код
def login(username, password)
  if username == 'admin' && password == 'password'
    puts 'Login successful'
  else
    puts 'Login failed'
  end
end
```


В этом несоответствующем коде функция входа в систему выполняет базовую операцию входа в систему, сравнивая предоставленные имя пользователя и пароль с жестко закодированными значениями. Однако код не предоставляет конкретной информации о причинах неудач при входе в систему, что может привести к упущению важных для безопасности деталей, которые могут помочь в выявлении и устранении проблем с аутентификацией или потенциальных атак.

Для решения этой проблемы безопасности очень важно включать достаточное количество информации, относящейся к безопасности, при выполнении операций аутентификации или авторизации. Вот пример совместимого кода, включающего информацию, имеющую отношение к безопасности:





<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
# Соответствующий код
def login(username, password)
  if username == 'admin' && password == 'password'
    puts 'Login successful'
  else
    puts 'Login failed: Invalid username or password'
  end
end
```


В совместимом коде при неудачном входе в систему выдается более информативное сообщение, указывающее на причину неудачи: "Неверное имя пользователя или пароль". Эта дополнительная информация может помочь пользователям понять, почему попытка входа в систему оказалась неудачной, и направить их на исправление своих учетных данных.



Включая в сообщения об ошибках или ответные сообщения информацию, имеющую отношение к безопасности, вы обеспечиваете прозрачность и обратную связь с пользователями, позволяя им предпринять соответствующие действия. Это поможет предотвратить потенциальные риски безопасности, такие как атаки методом грубой силы, попытки несанкционированного доступа или замешательство пользователей.


Важно найти баланс между предоставлением полезной информации и недопущением раскрытия конфиденциальных данных, которые могут помочь злоумышленникам. Убедитесь, что сообщения об ошибках носят информативный характер и не раскрывают лишней информации, которая может быть использована злоумышленниками. Регулярно пересматривайте и обновляйте свои методы обработки ошибок и сообщения, чтобы привести их в соответствие с передовым опытом и учесть возникающие угрозы безопасности.











## Помещение конфиденциальной информации в файл журнала

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
# Несоответствующий код
logger = Logger.new('application.log')

def log_sensitive_info(username, password)
  logger.info("Login attempt - Username: #{username}, Password: #{password}")
end
```

В этом коде, не соответствующем требованиям, функция log_sensitive_info регистрирует попытку входа в систему с именем пользователя и паролем, непосредственно интерполированными в сообщение журнала. Хранение конфиденциальной информации, такой как пароли, в файлах журнала может привести к серьезным рискам безопасности. Файлы журнала могут быть доступны администраторам, разработчикам или злоумышленникам, а наличие конфиденциальной информации может привести к несанкционированному доступу, раскрытию или неправомерному использованию.

Чтобы решить эту проблему безопасности, необходимо избегать записи конфиденциальной информации в журнал или принять меры для надлежащей защиты и обеспечения безопасности записанных в журнал данных. Вот пример совместимого кода, который предотвращает регистрацию конфиденциальной информации:







<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
# Соответствующий код
logger = Logger.new('application.log')

def log_login_attempt(username)
  logger.info("Login attempt - Username: #{username}")
end
```


В коде, соответствующем требованиям, функция log_login_attempt регистрирует только имя пользователя, а не секретный пароль. Исключив пароль из сообщения журнала, код избегает сохранения конфиденциальной информации в файле журнала.

При работе с конфиденциальной информацией важно придерживаться безопасных методов ведения журнала. Вот некоторые рекомендации:

1. Избегайте записи в журнал конфиденциальной информации, такой как пароли, номера кредитных карт или персональные данные (PII).
2. Используйте методы маскировки журналов, чтобы заменить конфиденциальные данные простыми или отредактированными значениями.
3. Внедрите механизм фильтрации журналов, чтобы исключить конфиденциальную информацию из журналов перед их записью на диск или передачей.
4. Регулярно проверяйте и защищайте доступ к файлам журналов, обеспечивая их доступность только для уполномоченного персонала.
5. Шифруйте файлы журналов или храните их в безопасных местах для защиты от несанкционированного доступа или несанкционированного вмешательства.

Отказ от регистрации конфиденциальной информации или применение мер по защите зарегистрированных данных позволит вам сохранить конфиденциальность и целостность конфиденциальных данных, снизить риск несанкционированного доступа или раскрытия информации, а также обеспечить соблюдение требований по защите данных.




## Подделка запросов со стороны сервера (SSRF)

<span class="d-inline-block p-2 mr-1 v-align-middle bg-red-000"></span>Несоответствующий код:


```php
require 'open-uri'

# Несоответствующий код
def fetch_url(url)
  data = open(url).read
  # Обработка полученных данных
end
```

В этом несовместимом коде функция fetch_url принимает на вход URL и напрямую использует метод open из библиотеки open-uri для чтения содержимого указанного URL. Такой подход может быть опасен, поскольку позволяет злоумышленнику манипулировать параметром URL и потенциально получить доступ к внутренним ресурсам или выполнить несанкционированные действия от имени сервера.

Для решения этой проблемы безопасности очень важно реализовать надлежащие средства защиты от атак SSRF. Вот пример совместимого кода, который устраняет уязвимости SSRF:







<span class="d-inline-block p-2 mr-1 v-align-middle bg-green-000"></span>Соответствующий код:


```php
require 'open-uri'
require 'uri'

# Соответствующий код
def fetch_url(url)
  parsed_url = URI.parse(url)
  if parsed_url.host == 'trusted-domain.com'
    data = open(url).read
    # Обработка полученных данных
  else
    # Работа с недоверенным или ограниченным доменом
    puts 'Access to the specified domain is not allowed.'
  end
end
```

В совместимом коде метод URI.parse используется для разбора входного URL и получения имени хоста. Проверяя атрибут host разобранного URL по белому списку доверенных доменов (в данном случае 'trusted-domain.com'), код гарантирует, что запросы будут отправлены только в разрешенные места назначения.

Если входной URL-адрес принадлежит недоверенному или ограниченному домену, код обрабатывает этот случай, выводя соответствующее сообщение или предпринимая другие необходимые действия, например, регистрируя событие, уведомляя администраторов или отклоняя запрос.

Для предотвращения атак SSRF важно поддерживать надежный белый список доверенных доменов и тщательно проверять вводимые пользователем данные. Кроме того, рассмотрите возможность внедрения дополнительных средств защиты, таких как:

* Ограничение использования IP-адресов и частных/внутренних сетевых ресурсов.
* Ограничение скорости или дросселирование запросов для предотвращения злоупотреблений.
* Мониторинг и регистрация исходящих запросов для обнаружения и реагирования на подозрительные или несанкционированные действия.

Реализовав надлежащую проверку ввода, белые списки доменов и другие меры безопасности, вы можете значительно снизить риск атак SSRF и гарантировать, что запросы будут направляться только в доверенные и целевые адреса.

