---
layout: default
title:  SAST
parent: Code
---

# SAST- Статическое тестирование безопасности приложений
{: .no_toc }

## Оглавление
{: .no_toc .text-delta }

1. TOC
{:toc}

---





SAST, или статическое тестирование безопасности приложений, - это метод, используемый в области безопасности приложений для анализа исходного кода приложения на предмет уязвимостей. Инструменты SAST работают путем сканирования исходного кода приложения без фактического выполнения кода, отыскивая общие ошибки кодирования, недостатки безопасности и потенциальные уязвимости.

SAST является разновидностью тестирования "белого ящика", то есть предполагает, что тестировщик имеет доступ к исходному коду тестируемого приложения. Это позволяет инструментам SAST проводить тщательный анализ кодовой базы, выявляя потенциальные уязвимости, которые могут быть не видны при использовании других методов тестирования.




| SAST инструменты    | Описание   | Поддерживаемые языки |
|:---------------|:---------------------|:---------------------|
| `Checkmarx` | Инструмент SAST, который анализирует исходный код на предмет уязвимостей в системе безопасности, предоставляя разработчикам информацию о потенциальных проблемах в режиме реального времени.	 | Java, .NET, PHP, Python, Ruby, Swift, C/C++, Objective-C, Scala, Kotlin, JavaScript |
| `SonarQube` | Инструмент, обеспечивающий непрерывную проверку кода, выявляющий и сообщающий о потенциальных уязвимостях в системе безопасности, а также о проблемах с качеством кода.	 | Более 25 языков программирования, включая Java, C/C++, Python, JavaScript, PHP, Ruby |
| `Fortify Static Code Analyzer` | Инструмент SAST, который анализирует исходный код на предмет уязвимостей в системе безопасности, предоставляя подробные отчеты и рекомендации по улучшению защиты.	 | Java, .NET, C/C++, Python, JavaScript |
| `Veracode Static Analysis` | Инструмент SAST, который анализирует код на предмет уязвимостей в системе безопасности и соответствия отраслевым стандартам, предоставляя подробные отчеты и практические рекомендации.	 | Более 25 языков программирования, включая Java, .NET, Python, Ruby, PHP, JavaScript, C/C++ |
| `Semgrep` | Semgrep разработан для быстрого и простого использования и поддерживает множество языков программирования, включая Python, Java, JavaScript, Go и другие. Он использует простой язык сопоставления образцов для выявления шаблонов кода, которые, как известно, являются уязвимыми, и может быть настроен на сканирование определенных частей кодовой базы, таких как отдельный файл или каталог.	 | Более 25 языков программирования, включая Java, .NET, Python, Ruby, PHP, JavaScript, C/C++ |
| `CodeQL` | CodeQL основан на базе данных семантических представлений кода, что позволяет ему выполнять сложный анализ кода, который другие инструменты статического анализа могут пропустить. Он поддерживает широкий спектр языков программирования, включая C, C++, C#, Java, JavaScript, Python и другие. CodeQL может использоваться для анализа как открытого, так и проприетарного кода, причем как разработчиками, так и исследователями безопасности.	 | Более 25 языков программирования, включая Java, .NET, Python, Ruby, PHP, JavaScript, C/C++ |





## Semgrep

Semgrep разработан для быстрого и простого использования и поддерживает множество языков программирования, включая Python, Java, JavaScript, Go и другие. Он использует простой язык сопоставления образцов для выявления шаблонов кода, которые, как известно, являются уязвимыми, и может быть настроен на сканирование определенных частей кодовой базы, таких как отдельный файл или каталог.

Semgrep можно использовать в процессе разработки программного обеспечения для выявления уязвимостей на ранних стадиях, до того как ими смогут воспользоваться злоумышленники. Его можно интегрировать в конвейер CI/CD для автоматического сканирования изменений кода по мере их внесения, а также использовать для обеспечения соблюдения политик безопасности и стандартов кодирования в организации.

создайте образец правила. Вот шаги:

1. Установите и настройте Semgrep: Чтобы использовать Semgrep, вам необходимо установить его в своей системе. Вы можете скачать Semgrep с официального сайта или установить его с помощью менеджера пакетов, например pip. После установки необходимо создать проект и настроить параметры сканирования.

2. Создайте новое правило Semgrep: Чтобы создать новое правило Semgrep, необходимо написать YAML-файл, определяющий правило. Файл YAML должен содержать следующую информацию:

* ID правила: это уникальный идентификатор правила.
* Имя правила: это описательное имя правила.
* Описание правила: Здесь описывается, что делает правило и почему оно важно.
* Шаблон правила: Это шаблон, который Semgrep будет использовать для поиска уязвимости.
* Серьезность правила: Это уровень серьезности уязвимости (например, высокий, средний, низкий).
* Язык правила: Это язык программирования, к которому применяется правило (например, Python, Java, JavaScript).
* Теги правила: Это необязательные теги, которые можно использовать для категоризации правила.


Вот пример правила, которое проверяет наличие уязвимостей SQL-инъекций в коде Python:

```
id: sql-injection-py
name: SQL Injection in Python Code
description: Checks for SQL injection vulnerabilities in Python code.
severity: high
language: python
tags:
  - security
  - sql-injection
patterns:
  - pattern: |
      db.execute("SELECT * FROM users WHERE username = '" + username + "' AND password = '" + password + "'")
    message: |
      SQL injection vulnerability found in line {line}: {code}
```

3. Запустите Semgrep с новым правилом: После создания нового правила вы можете запустить Semgrep для сканирования кода. Чтобы запустить Semgrep, вам нужно указать путь к коду, который вы хотите просканировать, и путь к YAML-файлу, содержащему правило. Вот пример команды:

```
semgrep --config path/to/rule.yaml path/to/code/
```

4. Просмотрите результаты сканирования: После завершения сканирования Semgrep отобразит результаты в терминале. Результаты будут содержать информацию о найденных уязвимостях, включая уровень серьезности, место в коде, где была найдена уязвимость, и код, который вызвал правило.


Как использовать Semgrep в конвейере CI/CD на GitHub:

1. Настройте Semgrep в своем проекте: Чтобы использовать Semgrep в конвейере CI/CD, вам нужно установить и настроить его в своем проекте. Это можно сделать, добавив файл semgrep.yml в корневой каталог проекта. Файл semgrep.yml должен содержать правила, которые вы хотите применить к своей кодовой базе.

Вот пример файла semgrep.yml, который проверяет наличие уязвимостей SQL-инъекций в коде Python:

```
rules:
  - id: sql-injection-py
    pattern: db.execute("SELECT * FROM users WHERE username = $username AND password = $password")
```

2. Создайте рабочий процесс GitHub: После того как вы настроили Semgrep в своем проекте, вам нужно создать рабочий процесс GitHub, который будет запускать Semgrep как часть вашего конвейера CI/CD. Чтобы создать рабочий процесс, вам нужно создать каталог .github/workflows в вашем проекте и добавить файл YAML, который определяет рабочий процесс.


Вот пример рабочего процесса semgrep.yml, который запускает Semgrep при каждом отправлении в мастер-ветку:

```
name: Semgrep
on:
  push:
    branches:
      - master
jobs:
  semgrep:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v2
    - name: Run Semgrep
      uses: returntocorp/semgrep-action@v1
      with:
        args: -c semgrep.yml

```


3. Внесите изменения в GitHub: После того как вы создали рабочий процесс, вам нужно отправить изменения в свой репозиторий GitHub. Это запустит рабочий процесс для запуска Semgrep на вашей кодовой базе.

4. Просмотрите результаты: После завершения рабочего процесса вы можете просмотреть результаты на вкладке GitHub Actions. Результаты будут содержать информацию о найденных уязвимостях, включая уровень серьезности, место в коде, где была найдена уязвимость, и код, который вызвал правило.



## CodeQL

CodeQL основан на базе данных семантических представлений кода, что позволяет ему выполнять сложный анализ кода, который другие инструменты статического анализа могут пропустить. Он поддерживает широкий спектр языков программирования, включая C, C++, C#, Java, JavaScript, Python и другие. CodeQL может использоваться для анализа как открытого, так и проприетарного кода, причем как разработчиками, так и исследователями безопасности.

Чтобы использовать CodeQL, разработчики пишут запросы на специальном языке запросов QL. QL - это декларативный язык, который позволяет разработчикам выражать сложные анализы в краткой и понятной форме. Запросы могут быть написаны для проверки широкого спектра проблем, таких как переполнение буфера, уязвимости SQL-инъекций, условия гонки и многое другое.

CodeQL может быть интегрирован в различные инструменты разработки, такие как IDE, средства проверки кода и конвейеры CI/CD. Это позволяет разработчикам автоматически запускать CodeQL в рамках процесса разработки и выявлять проблемы на ранних этапах цикла разработки.

Вот пример того, как создать правило CodeQL и запустить его:

1. Определите проблему: Допустим, мы хотим создать правило CodeQL для обнаружения уязвимостей SQL-инъекций в веб-приложении на Java.

2. Напишите запрос: Для написания запроса мы можем использовать библиотеки CodeQL для Java и встроенные функции CodeQL для обнаружения уязвимостей SQL-инъекций. Вот пример запроса:


```
import java

class SqlInjection extends JavaScript {
  SqlInjection() {
    this = "sql injection"
  }

  from MethodCall call, DataFlow::PathNode arg, SQL::StringExpression sqlExpr
  where call.getMethod().getName() = "executeQuery" and
        arg = call.getArgument(1) and
        arg = sqlExpr.getAnOperand() and
        exists (SQL::TaintedFlow tainted |
          tainted = dataFlow::taintThrough(arg, tainted) and
          tainted.(SQL::Source) and
          tainted.(SQL::Sink)
        )
  select call, "Potential SQL injection vulnerability"
}

```

Этот запрос ищет вызовы метода executeQuery со строковым аргументом, который может быть испорчен пользовательским вводом, а затем проверяет, не используется ли этот аргумент таким образом, что может привести к уязвимости SQL-инъекции. Если уязвимость обнаружена, запрос возвращает вызов и сообщение, указывающее на потенциальную уязвимость.

3. Проверка запроса: Чтобы протестировать запрос, мы можем запустить его на небольшом примере нашей кодовой базы с помощью инструмента CodeQL CLI. Вот пример команды:

```
$ codeql query run --database=MyAppDB --format=csv --output=results.csv path/to/query.ql
```

Эта команда выполняет запрос к базе данных CodeQL с именем MyAppDB и выводит результаты в CSV-файл с именем results.csv.

4. Интегрируйте запрос: Чтобы интегрировать запрос в процесс разработки, мы можем добавить его в базу данных CodeQL и запускать автоматически в рамках конвейера CI/CD. Это можно сделать с помощью инструмента CodeQL CLI и CodeQL GitHub Action.

Вот пример команды для добавления запроса в базу данных CodeQL:

```
$ codeql database analyze MyAppDB --queries=path/to/query.ql
```

А вот пример рабочего процесса GitHub Action, который будет автоматически запускать запрос при каждом пуше в мастер-ветку:

```
name: CodeQL

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/
```



## Git

1- Сканирование репозитория Git:



```
gitleaks --repo=/path/to/repository
```

или

```
trufflehog --regex --entropy=True /path/to/repository
```


2- Определение правил и конфигураций

```
gitleaks --config=/path/to/config.yaml
```


3- Создайте HTML-отчет о результатах сканирования

```
trufflehog --regex --entropy=True --output=results.html /path/to/repository
```


4- Генерируйте вывод в формате JSON для дальнейшей обработки или создания отчетов

```
trufflehog --json --output=results.json /path/to/repository
```


Список Regex:

| SAST инструменты    | Описание   | Поддерживаемые языки |
|:---------------|:---------------------|:---------------------|
| `API Keys` | Сопоставляет потенциальные ключи API, которые обычно представляют собой комбинацию заглавных букв или буквенно-цифровых символов с минимальной длиной 24 знака.  | `(?:\b|_)(?:[A-Z]{2,}|\w{24,})(?:\b|_)` |
| `AWS Access Keys` | Сопоставляет потенциальные ключи API, которые обычно представляют собой комбинацию заглавных букв или буквенно-цифровых символов с минимальной длиной 24 знака.  | `(?:\b|_)(?:[A-Z]{2,}|\w{24,})(?:\b|_)` |
| `Cryptocurrency Wallets` | Совпадает с адресами кошельков популярных криптовалют, включая Bitcoin (BTC), Ethereum (ETH), Litecoin (LTC), Monero (XMR) и Dogecoin (DOGE).  | `(?i)(?:btc|bitcoin|eth|ethereum|ltc|litecoin|xmr|monero|doge|dogecoin)(?:[1-9A-HJ-NP-Za-km-z]{25,34})` |
| `Email Addresses` | Сопоставляет адреса электронной почты с алфавитно-цифровыми символами, точками, подчеркиваниями, дефисами и доменом, содержащим не менее двух букв.  | `[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}` |
| `Private Keys` | Сопоставляет 40-символьные строки в base64-кодировке, часто используемые для закрытых ключей.  | `(?:[^a-zA-Z0-9/+]|^)([a-zA-Z0-9/+]{40})(?:[^a-zA-Z0-9/+]|$)` |
| `Passwords` | Подбирает пароли или парольные фразы, состоящие не менее чем из 8 символов, перед которыми стоит "password", "passphrase" или "secret" и за которыми следует символ пробела, двоеточие или двоеточие в кодировке URL (%3A).  | `(?i)(?:pass(?:word|phrase)|secret)(?:[\s:=]|%3A)(["']?[\w!@#$%^&*()]{8,}["']?)` |
| `Social Security Numbers (SSN)` | Сопоставляет номера социального страхования США с черточками или без них.  | `\d{3}[-]?\d{2}[-]?\d{4}` |
| `URLs with Query Parameters` | Сопоставляет URL с параметрами запроса, гарантируя, что параметр запроса содержит хотя бы один символ.  | `(http|https):\/\/[^\s/$.?#].[^\s]*\?[^\s]*` |
| `Credit Card Numbers` | Сопоставляет 16-значные номера кредитных карт с тире и пробелами или без них в формате XXXX-XXXX-XXXX-XXXX or XXXXXXXXXXXXXXXX.  | `(\d{4}[- ]){3}\d{4}|\d{16}` |



## SBOM

1- Сгенерируйте SBOM из проекта Maven:

```
mvn org.cyclonedx:cyclonedx-maven-plugin:makeBom
```

2- Генерация SBOM из проекта Gradle

```
./gradlew cyclonedx
```

3- Укажите формат вывода

```
mvn org.cyclonedx:cyclonedx-maven-plugin:makeBom --format XML
```

4- Включение хэшей в SBOM

```
mvn org.cyclonedx:cyclonedx-maven-plugin:makeBom -DincludeHashes=true
```


5- Исключить конкретные компоненты

```
mvn org.cyclonedx:cyclonedx-maven-plugin:makeBom -Dexclude=com.example:unused-component
```


6- Включите только прямые зависимости

```
mvn org.cyclonedx:cyclonedx-maven-plugin:makeBom -DincludeDependencies=false
```


7- Укажите выходной файл

```
mvn org.cyclonedx:cyclonedx-maven-plugin:makeBom -DoutputFile=/path/to/bom.xml
```

8- Укажите формат вывода

```
mvn org.cyclonedx:cyclonedx-maven-plugin:makeBom --format XML
```


## Retire.js


Вы можете использовать Retire.js CLI для сканирования каталога или определенного файла JavaScript. Вот пример команды для сканирования каталога:


```
retire --path <directory-path>
```


