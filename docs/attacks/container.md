---
layout: default
title: Container Attacks
parent: Attacks
---

# Атаки на контейнеры
{: .no_toc }


## Оглавление
{: .no_toc .text-delta }

1. TOC
{:toc}

---


## Небезопасные образы контейнеров: 

Использование образов контейнеров, содержащих уязвимые или устаревшие программные компоненты, которые могут быть использованы злоумышленниками. Пример: Образ контейнера, содержащий уязвимую версию программного обеспечения веб-сервера.

### Вредоносные изображения через Aqua

* docker-network-bridge-
* ipv6:0.0.2
* docker-network-bridge-
* ipv6:0.0.1
* docker-network-ipv6:0.0.12
* ubuntu:latest
* ubuntu:latest
* ubuntu:18.04
* busybox:latest
* alpine: latest
* alpine-curl
* xmrig:latest
* alpine: 3.13
* dockgeddon: latest
* tornadorangepwn:latest
* jaganod: latest
* redis: latest
* gin: latest (built on host)
* dockgeddon:latest
* fcminer: latest
* debian:latest
* borg:latest
* docked:latestk8s.gcr.io/pause:0.8
* dockgeddon:latest
* stage2: latest
* dockerlan:latest
* wayren:latest
* basicxmr:latest
* simpledockerxmr:latest
* wscopescan:latest
* small: latest
* app:latest
* Monero-miner: latest
* utnubu:latest
* vbuntu:latest
* swarm-agents:latest
* scope: 1.13.2
* apache:latest
* kimura: 1.0
* xmrig: latest
* sandeep078: latest
* tntbbo:latest
* kuben2


### Другие изображения

* OfficialImagee
* Ubuntuu
* Cent0S
* Alp1ne
* Pythoon




## Контейнер с привилегиями

Запуск контейнеров с повышенными привилегиями, позволяющий потенциальным злоумышленникам получить контроль над базовой хост-системой. Пример: Запуск контейнера с доступом на уровне root и неограниченными возможностями.

В коде, не соответствующем требованиям, контейнер запускается с флагом --privileged, что включает привилегированный режим. Это предоставляет контейнеру неограниченный доступ к хост-системе, потенциально нарушая ее границы безопасности.



```
# Несоответствие требованиям: Привилегированный контейнер

FROM ubuntu
...
# Запуск контейнера в привилегированном режиме
RUN docker run -it --privileged ubuntu /bin/bash
```

Соответствующий код устраняет уязвимость, запуская контейнер без привилегированного режима. Это ограничивает доступ контейнера к системным ресурсам и снижает риск повышения привилегий и несанкционированного доступа к хосту.




```
# Соответствует требованиям: Непривилегированный контейнер

FROM ubuntu
...
# Запуск контейнера без привилегированного режима
RUN docker run -it ubuntu /bin/bash
```

## Открытые API-интерфейсы контейнеров 

Небезопасное раскрытие API-интерфейсов контейнеров без надлежащей аутентификации или контроля доступа, что позволяет злоумышленникам манипулировать контейнерами или извлекать из них конфиденциальную информацию. Пример: Раскрытие API Docker без какой-либо аутентификации или шифрования.

В коде, не соответствующем требованиям, API контейнера открыт на порту 8080 без каких-либо механизмов аутентификации или авторизации. Это позволяет получить неограниченный доступ к API контейнера, что делает его уязвимым для несанкционированного доступа и потенциальных атак.



```
# Несоответствие требованиям: Открытый API контейнера без аутентификации/авторизации

FROM nginx
...
# Открыть API контейнера на порту 8080
EXPOSE 8080
```

Соответствующий код устраняет уязвимость, открывая API контейнера на внутреннем порту 8080 и используя обратный прокси или API-шлюз для аутентификации и авторизации. Обратный прокси или API-шлюз выступает в качестве уровня безопасности, обрабатывая запросы на аутентификацию/авторизацию перед их передачей в API контейнера.

Чтобы еще больше повысить безопасность открытых API-интерфейсов контейнеров, обратите внимание на следующие лучшие практики:

1. Внедряйте надежные механизмы аутентификации и авторизации: Используйте стандартные протоколы аутентификации (например, OAuth, JWT) и применяйте контроль доступа на основе ролей и разрешений пользователей.
1. Используйте шифрование на транспортном уровне (Transport Layer Security, TLS): Защитите обмен данными между клиентами и API контейнера с помощью сертификатов TLS для защиты от подслушивания и несанкционированного доступа.
1. Регулярно отслеживайте и регистрируйте активность API: Внедрите механизмы регистрации и мониторинга для обнаружения и реагирования на подозрительную или вредоносную активность.
1. Применяйте ограничение скорости и дросселирование: Защитите API от злоупотреблений и атак типа "отказ в обслуживании", применяя ограничения скорости и дросселирование запросов.


```
# Соответствие требованиям: Защищенный контейнерный API с аутентификацией/авторизацией

FROM nginx
...
# Открыть API контейнера на порту 8080 (внутренний)
EXPOSE 8080

# Используйте обратный прокси-сервер или API-шлюз для аутентификации/авторизации
```


## Побег из контейнера

Использование уязвимостей во времени выполнения контейнера или неправильной конфигурации для выхода из изоляции контейнера и получения несанкционированного доступа к операционной системе хоста. Пример: Эксплуатация уязвимости во времени выполнения контейнера для получения доступа к хост-системе и другим контейнерам.


Приведенный ниже код создает и запускает контейнер без каких-либо мер изоляции безопасности. Это делает контейнер уязвимым для атак на выход из контейнера, когда злоумышленник может использовать уязвимости во времени выполнения контейнера или неверно настроенные параметры безопасности для получения несанкционированного доступа к хост-системе.

```
# Несоответствие требованиям: Запуск контейнера без надлежащей изоляции безопасности

require 'docker'

# Создайте контейнер с настройками по умолчанию
container = Docker::Container.create('Image' => 'nginx')
container.start
```

Мы вводим усовершенствования безопасности, чтобы снизить риск побега контейнера. Параметр HostConfig используется для настройки параметров безопасности контейнера. Здесь мы:

Устанавливаем 'Privileged' => false, чтобы отключить привилегированный режим, который ограничивает доступ к устройствам и возможностям хоста.
Используем 'CapDrop' => ['ALL'], чтобы исключить все возможности из контейнера, минимизируя потенциальную поверхность атаки.
Добавьте 'SecurityOpt' => ['no-new-privileges'], чтобы предотвратить повышение привилегий внутри контейнера.


```
# Соответствие требованиям: Запуск контейнера с усиленной изоляцией безопасности

require 'docker'

# Создание контейнера с повышенными параметрами безопасности
container = Docker::Container.create(
  'Image' => 'nginx',
  'HostConfig' => {
    'Privileged' => false,           # Отключить привилегированный режим
    'CapDrop' => ['ALL'],            # Отбросьте все возможности
    'SecurityOpt' => ['no-new-privileges']  # Предотвращение эскалации привилегий
  }
)
container.start
```


## Подделка образов контейнеров

Изменение или замена образов контейнеров на вредоносные версии, которые могут содержать вредоносное ПО, бэкдоры или уязвимые компоненты. Пример: Внесение изменений в образ контейнера с целью внедрения вредоносного кода, похищающего конфиденциальную информацию.


Приведенный ниже код напрямую извлекает и запускает образ контейнера, не проверяя его целостность. Это делает приложение уязвимым к взлому образа контейнера, когда злоумышленник может изменить образ контейнера, включив в него вредоносный код или нарушив безопасность приложения.

```
#Извлечение и запуск образа контейнера без проверки целостности

require 'docker'

# Извлеките образ контейнера
image = Docker::Image.create('fromImage' => 'nginx')

# Запустите образ контейнера
container = Docker::Container.create('Image' => image.id)
container.start
```

мы решаем эту проблему, внедряя проверку целостности. Код вычисляет ожидаемый дайджест извлеченного образа с помощью хэш-алгоритма SHA256. Затем он сравнивает этот ожидаемый дайджест с фактическим дайджестом образа, полученным из Docker API. Если дайджесты не совпадают, выдается сообщение о сбое проверки целостности, указывающее на то, что образ мог быть подделан.

```
# Соответствие требованиям: Извлечение и запуск образа контейнера с проверкой целостности

require 'docker'
require 'digest'

# Название и тег изображения
image_name = 'nginx'
image_tag = 'latest'

# Извлеките образ контейнера
image = Docker::Image.create('fromImage' => "#{image_name}:#{image_tag}")

# Проверьте целостность извлеченного изображения
expected_digest = Digest::SHA256.hexdigest(image.connection.get("/images/#{image.id}/json").body)
actual_digest = image.info['RepoDigests'].first.split('@').last
if expected_digest != actual_digest
  raise "Integrity verification failed for image: #{image_name}:#{image_tag}"
end

# Запустите образ контейнера
container = Docker::Container.create('Image' => image.id)
container.start
```

## Небезопасная конфигурация контейнера

Ошибки в настройках контейнера, такие как слабый контроль доступа или чрезмерные разрешения, позволяющие злоумышленникам скомпрометировать контейнер или его окружение. Пример: Запуск контейнера с ненужными возможностями или небезопасными точками монтирования.

Несоответствующий требованиям код создает и запускает контейнер с настройками по умолчанию, которые могут иметь небезопасные конфигурации. Эти неправильные конфигурации могут привести к уязвимостям, таким как повышение привилегий, чрезмерные привилегии контейнера или раскрытие конфиденциальных ресурсов.


```
# Несоответствие требованиям: Запуск контейнера с небезопасной конфигурацией

require 'docker'

# Создайте контейнер с настройками по умолчанию
container = Docker::Container.create('Image' => 'nginx')
container.start
```

В совместимом коде мы решаем эти проблемы безопасности, применяя безопасные конфигурации контейнеров. Параметр HostConfig используется для указания конфигурации контейнера. Здесь мы:

Устанавливаем 'ReadOnly' => true, чтобы сделать файловую систему контейнера доступной только для чтения, что предотвращает возможные взломы и несанкционированные модификации.
Используем 'CapDrop' => ['ALL'], чтобы отбросить все возможности контейнера, минимизируя поверхность атаки и снижая потенциальное влияние повышения привилегий.
Добавьте 'SecurityOpt' => ['no-new-privileges'], чтобы предотвратить получение контейнером дополнительных привилегий.
Укажите 'NetworkMode' => 'bridge', чтобы изолировать контейнер в мостовой сети, обеспечивая разделение с хостом и другими контейнерами.
Используйте 'PortBindings', чтобы привязать порт контейнера к определенному порту хоста ('80/tcp' => [{ 'HostPort' => '8080' }]). Это ограничивает сетевой доступ к контейнеру и позволяет не открывать лишние порты.

```
# Соответствие требованиям: Запуск контейнера с безопасной конфигурацией

require 'docker'

# Создание контейнера с безопасными настройками
container = Docker::Container.create(
  'Image' => 'nginx',
  'HostConfig' => {
    'ReadOnly' => true,               # Установите контейнер как доступный только для чтения
    'CapDrop' => ['ALL'],             # Отбросьте все возможности
    'SecurityOpt' => ['no-new-privileges'],  # Предотвращение эскалации привилегий
    'NetworkMode' => 'bridge',        # Используйте мостовую сеть для изоляции
    'PortBindings' => { '80/tcp' => [{ 'HostPort' => '8080' }] }  # Bind container port to a specific host port
  }
)
container.start
```



## Отказ в обслуживании (DoS)

Перегрузка ресурсов контейнера или использование уязвимостей во времени выполнения контейнера для нарушения доступности контейнерных приложений. Пример: Осуществление DoS-атаки на контейнер путем перегрузки его чрезмерными запросами.


Фрагмент кода, не соответствующий требованиям, показывает Dockerfile, который уязвим для перегрузки ресурсов и DoS-атак. В нем не реализовано никаких ограничений на ресурсы, что позволяет контейнеру потреблять неограниченное количество ресурсов. Это может привести к DoS-ситуации, если злоумышленник перегрузит контейнер чрезмерными запросами или воспользуется уязвимостями во времени выполнения контейнера.




```
# Несоответствие требованиям: Уязвимый Dockerfile с неограниченным распределением ресурсов

FROM nginx:latest

COPY app /usr/share/nginx/html

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
```

Соответствующий фрагмент кода устраняет эту уязвимость, не устанавливая явных ограничений на ресурсы. Однако необходимо реализовать управление ресурсами и ограничить ресурсы контейнера в зависимости от требований приложения и ресурсов, доступных в вашей среде. Этого можно достичь, настроив ограничения ресурсов, таких как процессор, память и пропускная способность сети, с помощью платформ оркестровки контейнеров или файлов Docker-compose.



```
version: '3'
services:
  nginx:
    image: nginx:latest
    ports:
      - 80:80
    volumes:
      - ./app:/usr/share/nginx/html
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: '256M'
```


## Уязвимости ядра

Использование уязвимостей в ядре или операционной системе хоста для получения несанкционированного доступа или контроля над контейнерами. Пример: Эксплуатация уязвимости ядра для повышения привилегий и компрометации контейнеров.


```
# Несоответствие требованиям: Игнорирование уязвимостей ядра

docker run -d ubuntu:latest /bin/bash
```

Чтобы снизить уязвимость ядра, важно регулярно проверять наличие обновлений и применять патчи безопасности на хост-системе. Кроме того, вы можете использовать инструменты для сканирования и оценки состояния уязвимости ядра перед созданием контейнера Docker.

Вот пример совместимого кода, включающего проверку уязвимостей ядра с помощью инструмента kubehunter перед созданием контейнера:

```
# Соответствие требованиям: Проверка уязвимостей ядра

# Выполните оценку уязвимостей с помощью kubehunter
kubehunter scan

# Проверьте вывод на наличие уязвимостей в ядре

# Если уязвимости обнаружены, примите необходимые меры для их устранения

# Создайте контейнер Docker
docker run -d ubuntu:latest /bin/bash
```

В фрагменте кода, соответствующем требованиям, инструмент kubehunter используется для оценки уязвимости, в том числе для проверки уязвимостей ядра. Результаты работы инструмента изучаются, и если уязвимости найдены, то перед созданием Docker-контейнера предпринимаются соответствующие шаги по их устранению.



## Эксплуатация общего ядра

Контейнеры, использующие одно и то же ядро, могут быть уязвимы к атакам, использующим уязвимости ядра, что позволяет злоумышленникам воздействовать на несколько контейнеров. Пример: Эксплуатация уязвимости ядра для получения несанкционированного доступа к нескольким контейнерам на одном хосте.


В несоответствующем коде образ Docker устанавливает уязвимый пакет и запускает уязвимое приложение. Если злоумышленнику удастся использовать уязвимость ядра в контейнере, он может выйти из контейнера и скомпрометировать хост или другие контейнеры.



```
# Не соответствует требованиям: Уязвимость к прорыву контейнера

FROM ubuntu:latest

# Установите уязвимый пакет
RUN apt-get update && apt-get install -y vulnerable-package

# Запустите уязвимое приложение
CMD ["vulnerable-app"]
```


Соответствующий код устраняет уязвимость, гарантируя, что образ контейнера включает только необходимые и безопасные пакеты. Он регулярно обновляется и включает исправления безопасности для устранения известных уязвимостей. Запуск безопасного приложения внутри контейнера снижает риск его взлома.

Для дальнейшего повышения безопасности можно принять дополнительные меры, например, использовать методы изоляции контейнеров, например, запускать контейнеры с ограниченными привилегиями, использовать ядра с усиленной защитой (например, предоставляемые некоторыми контейнерными платформами), а также отслеживать и регистрировать активность контейнеров для выявления потенциальных попыток эксплуатации.

```
# Соответствует требованиям: Устранена уязвимость прорыва контейнера

FROM ubuntu:latest

# Установите обновления безопасности и необходимые пакеты
RUN apt-get update && apt-get upgrade -y && apt-get install -y secure-package

# Запуск безопасного приложения
CMD ["secure-app"]
```


## Небезопасная оркестровка контейнеров

Неправильная конфигурация или уязвимости в платформах для оркестровки контейнеров, таких как Kubernetes, могут привести к несанкционированному доступу, повышению привилегий или раскрытию конфиденциальной информации. Пример: Использование неправильно сконфигурированного кластера Kubernetes для получения несанкционированного доступа к важным ресурсам.


В коде, не соответствующем требованиям, определение Pod включает привилегированный режим для контейнера, предоставляя ему повышенные привилегии в среде оркестровки контейнеров. Если злоумышленник получит доступ к этому контейнеру, он сможет использовать повышенные привилегии для выполнения вредоносных действий на хосте или компрометации других контейнеров.


```
# Несоответствие требованиям: Уязвимость для повышения привилегий

apiVersion: v1
kind: Pod
metadata:
  name: vulnerable-pod
spec:
  containers:
    - name: vulnerable-container
      image: vulnerable-image
      securityContext:
        privileged: true  # Privileged mode enabled
```

Соответствующий код устраняет уязвимость путем явного отключения привилегированного режима для контейнера. Запуск контейнеров с пониженными привилегиями ограничивает последствия потенциальной компрометации и минимизирует площадь атаки.

Помимо отключения привилегированного режима, для повышения безопасности оркестровки контейнеров следует применять и другие меры безопасности. К ним относятся настройка соответствующих политик RBAC (Role-Based Access Control), включение сегментации и изоляции сети, регулярное применение патчей безопасности для системы оркестровки и мониторинг среды на предмет подозрительной активности.

```
# Соответствует требованиям: Смягчение эскалации привилегий

apiVersion: v1
kind: Pod
metadata:
  name: secure-pod
spec:
  containers:
    - name: secure-container
      image: secure-image
      securityContext:
        privileged: false  # Privileged mode disabled
```


## Сбросить все секреты

Под сбросом всех секретов в кластере Kubernetes понимается несанкционированное извлечение конфиденциальной информации, хранящейся в кластере в виде секретов. Эта атака позволяет злоумышленнику с соответствующими правами получить доступ ко всем секретам и вывести их из-под контроля, что может привести к дальнейшей компрометации.

Несоответствующий код:
Следующий код, не отвечающий требованиям, демонстрирует попытку сбросить все секреты из кластера Kubernetes без надлежащей авторизации:

```
# Получите все секреты с помощью команды kubectl
kubectl get secrets --all-namespaces -o json > secrets.json
```

Несоответствующий код использует команду kubectl get secrets для получения всех секретов в кластере во всех пространствах имен. Это действие предполагает, что у злоумышленника есть необходимые разрешения на доступ и список секретов, что потенциально может привести к несанкционированному доступу к конфиденциальной информации.

Соответствующий код:
Сброс всех секретов в кластере Kubernetes считается вредоносным действием, и предоставление совместимого кода для него было бы неуместным. Вместо этого я могу предоставить вам рекомендации по обеспечению безопасности секретов в кластере Kubernetes:

* Реализуйте принцип наименьших привилегий: Следуйте принципу наименьших привилегий при предоставлении прав пользователям и учетным записям служб. Назначайте только те привилегии, которые необходимы для выполнения конкретных задач, и регулярно проверяйте и аудируйте эти разрешения.

* Внедрите контроль доступа на основе ролей (RBAC): Настройте правила RBAC для ограничения доступа к секретам на основе принципа наименьших привилегий. Назначьте соответствующие роли пользователям и учетным записям служб, обеспечив им минимально необходимые разрешения.

* Используйте пространства имен: Используйте пространства имен Kubernetes для логического разделения ресурсов и изоляции секретов. Ограничьте доступ к секретам в определенных пространствах имен на основе принципа наименьших привилегий.

* Реализуйте шифрование секретов: Шифруйте секреты в состоянии покоя и при передаче. Kubernetes предоставляет такие механизмы, как функция Secrets Encryption Configuration, которая шифрует секреты, хранящиеся в etcd, хранилище ключевых значений кластера Kubernetes.

* Мониторинг журналов аудита сервера Kubernetes API: Включите и отслеживайте журналы аудита сервера Kubernetes API, чтобы обнаружить и расследовать подозрительные действия, такие как попытки несанкционированного доступа или ненормальные запросы к секретам.

* Регулярная ротация секретов: внедрите процесс регулярной ротации секретов, чтобы свести к минимуму последствия потенциальной компрометации. Это включает в себя установку времени истечения срока действия секретов и автоматизацию процесса ротации.

* Безопасный доступ к кластеру: Защитите доступ к кластеру Kubernetes, внедрив надежные механизмы аутентификации, такие как использование надежных паролей, многофакторная аутентификация (MFA) или интеграция с поставщиком идентификационных данных.




## Кража токена учетной записи службы стручка

Под кражей токена учетной записи сервиса понимается несанкционированное извлечение токена учетной записи сервиса из запущенного стручка в кластере Kubernetes. Токен учетной записи сервиса - это конфиденциальная учетная запись, предоставляющая доступ к API Kubernetes и другим ресурсам в кластере.

Несоответствующий код:
Следующий несоответствующий код демонстрирует попытку украсть токен учетной записи сервиса из запущенного стручка:

```
# Выполните команду для чтения токена учетной записи службы из капсулы
kubectl exec <pod-name> -- cat /var/run/secrets/kubernetes.io/serviceaccount/token
```

Несоответствующий код использует команду kubectl exec для выполнения команды (cat /var/run/secrets/kubernetes.io/serviceaccount/token) внутри указанного стручка. Эта команда считывает и выводит содержимое файла токена учетной записи сервиса. Злоумышленник, имеющий достаточный доступ к кластеру, может использовать этот метод для кражи токена и получения несанкционированного доступа к ресурсам Kubernetes.


Код соответствия:
Очень важно придерживаться лучших практик безопасности и предотвращать кражу токенов учетных записей служб. Ниже приведены некоторые рекомендации по защите токенов учетных записей служб pod:

* Ограничьте разрешения подкатов: Назначьте минимальные разрешения для стручков, используя принцип наименьших привилегий. Предоставляйте только необходимый доступ, требуемый для правильной работы капсулы.

* Используйте контроль доступа на основе ролей (RBAC): Внедрите правила RBAC, чтобы ограничить права доступа для подкад и ограничить возможность выполнения привилегированных команд или доступа к конфиденциальным файлам.

* Избегайте монтирования токенов учетных записей служб: При создании стручков избегайте монтирования маркера учетной записи службы в качестве тома или раскрытия его как переменной окружения. Минимизируйте поверхность атаки, не делая токен легкодоступным внутри капсулы.

* Регулярная ротация токенов учетных записей служб: Внедрите процесс периодической ротации токенов учетных записей служб. Это поможет смягчить воздействие скомпрометированного токена и сократить возможности для злоумышленников.

* Мониторинг активности подсистем: Включите ведение журналов и мониторинг активности подсистем. Регулярно просматривайте журналы и выявляйте любые подозрительные или несанкционированные попытки доступа.

* Внедрение политик безопасности: Используйте политики безопасности стручков (PSP) для обеспечения контроля безопасности при создании стручков, включая ограничения на выполнение привилегированных команд или доступ к конфиденциальным файлам.


## Создайте роль администратора кластера

Create Admin ClusterRole относится к процессу создания Kubernetes ClusterRole с административными правами. Он включает в себя создание учетной записи службы, связанной с ClusterRole, и создание привязки роли кластера, чтобы связать учетную запись службы с необходимыми привилегиями.

Несоответствующий код:
Следующий код, не отвечающий требованиям, демонстрирует создание роли Admin ClusterRole:

```
# Создание роли администратора кластера
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: admin-clusterrole
rules:
- apiGroups: [""]
  resources: ["*"]
  verbs: ["*"]

# Создайте учетную запись службы в пространстве имен kube-system
apiVersion: v1
kind: ServiceAccount
metadata:
  name: admin-serviceaccount
  namespace: kube-system

# Создайте привязку роли кластера, чтобы связать учетную запись службы с ролью ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: admin-clusterrolebinding
subjects:
- kind: ServiceAccount
  name: admin-serviceaccount
  namespace: kube-system
roleRef:
  kind: ClusterRole
  name: admin-clusterrole
  apiGroup: rbac.authorization.k8s.io
```

Несоответствующий код создает роль Admin ClusterRole с именем "admin-clusterrole" с широкими полномочиями (apiGroups: [""], resources: [""], verbs: [""]). Также создается учетная запись службы с именем "admin-serviceaccount" в пространстве имен kube-system и привязывается к роли Admin ClusterRole с помощью привязки роли кластера с именем "admin-clusterrolebinding". Эта конфигурация предоставляет учетной записи службы административный доступ ко всем ресурсам в кластере, что не рекомендуется по соображениям безопасности.

Соответствующий код:
При создании ClusterRole с административными правами важно следовать принципу наименьших привилегий и назначать только необходимые привилегии учетной записи службы. Ниже приведен пример совместимого кода:

```
# Создайте роль ClusterRole с соответствующими административными полномочиями
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: admin-clusterrole
rules:
- apiGroups: [""]
  resources: ["pods", "deployments"]
  verbs: ["get", "list", "create", "update", "delete"]

# Создайте учетную запись службы в пространстве имен kube-system
apiVersion: v1
kind: ServiceAccount
metadata:
  name: admin-serviceaccount
  namespace: kube-system

# Создайте привязку роли кластера, чтобы связать учетную запись службы с ролью ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: admin-clusterrolebinding
subjects:
- kind: ServiceAccount
  name: admin-serviceaccount
  namespace: kube-system
roleRef:
  kind: ClusterRole
  name: admin-clusterrole
  apiGroup: rbac.authorization.k8s.io
```

Соответствующий код создает роль администратора кластера с именем "admin-clusterrole" со специальными полномочиями для управления стручками и развертываниями. Он ограничивает глаголы "получить", "перечислить", "создать", "обновить" и "удалить" для этих ресурсов. Этот подход следует принципу наименьших привилегий, предоставляя учетной записи службы только необходимые разрешения. Благодаря такому подходу учетная запись службы, связанная с ролью Admin ClusterRole, имеет ограниченный административный доступ, что снижает потенциальное воздействие любого компрометации или неправильного использования этой учетной записи.



## Создание мандата клиентского сертификата

Create Client Certificate Credential - это процесс создания клиентского сертификата для привилегированного пользователя в кластере Kubernetes. Сертификат клиента может быть использован для аутентификации и доступа к кластеру с назначенными привилегиями.

Несоответствующий код:
Следующий код, не отвечающий требованиям, демонстрирует создание клиентского сертификата:

```
# Сгенерируйте закрытый ключ
openssl genrsa -out client.key 2048

# Создайте запрос на подписание сертификата (CSR)
openssl req -new -key client.key -out client.csr -subj "/CN=client"

# Печать CSR
cat client.csr
```

Несоответствующий код вручную генерирует закрытый ключ с помощью OpenSSL и создает запрос на подписание сертификата (CSR) для клиента с общим именем (CN) "клиент". Однако этот фрагмент кода не содержит шагов по утверждению CSR и выпуску сертификата клиента. Важно отметить, что этот несоответствующий код не соответствует лучшим практикам и требованиям безопасности для управления клиентскими сертификатами в кластере Kubernetes.

Соответствующий код:
Для создания клиентского сертификата в соответствии с требованиями безопасности рекомендуется использовать API Kubernetes Certificate Signing Request (CSR) и следовать надлежащим процедурам генерации и утверждения сертификата. Ниже приведен пример совместимого кода:

```
# Создайте объект CertificateSigningRequest
apiVersion: certificates.k8s.io/v1beta1
kind: CertificateSigningRequest
metadata:
  name: client-csr
spec:
  groups:
  - system:authenticated
  request: (base64-encoded CSR)
  usages:
  - client auth

# Утвердить CertificateSigningRequest
kubectl certificate approve client-csr

# Получение подписанного сертификата
kubectl get csr client-csr -o jsonpath='{.status.certificate}' | base64 -d > client.crt

# Печать сертификата и закрытого ключа клиента
echo "Client Certificate:"
cat client.crt

echo "Client Private Key:"
openssl rsa -in client.key -text
```

Код, соответствующий требованиям, демонстрирует правильный подход к созданию учетной записи клиентского сертификата. Он включает в себя создание объекта CertificateSigningRequest (CSR) с соответствующими метаданными, включая CSR в base64-кодировке и указанные использования. Затем CSR утверждается с помощью команды kubectl certificate approve, а подписанный сертификат извлекается с помощью kubectl get csr. Наконец, сертификат клиента и закрытый ключ распечатываются.



## Создание долгоживущего токена


Create Long-Lived Token - это процесс генерации токена с увеличенным сроком действия для учетной записи сервиса в кластере Kubernetes. Это позволяет злоумышленнику установить постоянство путем создания долгоживущего токена, который предоставляет постоянный доступ к взломанному кластеру.

Несоответствующий код:
Следующий несоответствующий код демонстрирует создание долгоживущего токена:

```
# Создайте токен учетной записи службы
kubectl create serviceaccount long-lived-token-sa

# Получить токен
kubectl get secret $(kubectl get serviceaccount long-lived-token-sa -o jsonpath='{.secrets[0].name}') -o jsonpath='{.data.token}' | base64 -d
```

Несоответствующий код генерирует токен учетной записи службы для вновь созданной учетной записи службы. Он извлекает токен из связанного секрета и декодирует его с помощью base64. Однако в этом фрагменте кода не указан срок действия токена, и будет применена политика истечения срока действия токена по умолчанию в кластере. Важно отметить, что этот несоответствующий код не придерживается концепции создания долгоживущего токена в явном виде.



Соответствующий код:
Для создания долгоживущего токена совместимый подход предполагает определение пользовательского TokenRequest с определенным сроком действия. Вот пример совместимого кода:

```
# Создание TokenRequest с продленным сроком действия
apiVersion: authentication.k8s.io/v1
kind: TokenRequest
metadata:
  name: long-lived-token
spec:
  audience: api
  expirationSeconds: 2592000  # 30 days (adjust as needed)
  tokenRequest:
    metadata:
      name: serviceaccount-name
      namespace: namespace-name

# Создание TokenRequest
kubectl create -f token-request.yaml

# Получить токен
kubectl get secret $(kubectl get tokenrequest long-lived-token -o jsonpath='{.status.secretName}') -o jsonpath='{.data.token}' | base64 -d
```

Соответствующий код определяет объект TokenRequest, в котором указывается желаемое время действия токена (например, 30 дней). Он также включает имя учетной записи службы и пространство имен. Затем TokenRequest создается с помощью kubectl create с YAML-файлом, содержащим определение объекта. Наконец, токен извлекается путем доступа к связанному секрету и декодирования значения токена.





## Вынос контейнера через монтирование тома hostPath

Прорыв контейнера через монтирование тома hostPath - это техника повышения привилегий в Kubernetes, при которой злоумышленник создает подкад, монтирующий корневую файловую систему всего узла с помощью тома hostPath. Это позволяет злоумышленнику выйти из контейнерного окружения капсулы и получить доступ к конфиденциальным файлам или выполнить привилегированные действия на базовой хост-системе.

Несоответствующий код:
Следующий код, не соответствующий требованиям, демонстрирует создание pod с монтированием тома hostPath:

```
apiVersion: v1
kind: Pod
metadata:
  name: hostpath-container-breakout
spec:
  containers:
  - name: attacker-container
    image: busybox
    command: ["/bin/sh", "-c"]
    args: ["cat /host/etc/passwd"]
    volumeMounts:
    - name: hostpath-volume
      mountPath: /host
  volumes:
  - name: hostpath-volume
    hostPath:
      path: /
```

Несоответствующий код определяет подкапсулу с именем "hostpath-container-breakout" с одним контейнером, основанным на образе "busybox". Контейнер выполняет команду "cat /host/etc/passwd" для чтения файла "/etc/passwd" на хост-системе. Том hostPath монтируется в "/host", обеспечивая доступ к корневой файловой системе узла.



Соответствующий код:
Чтобы предотвратить взлом контейнера через монтирование тома hostPath, необходимо применять надлежащие средства контроля безопасности и ограничения для ограничения доступа к хост-системе. Вот пример совместимого кода, позволяющего решить эту проблему:

```
apiVersion: v1
kind: Pod
metadata:
  name: secure-pod
spec:
  containers:
  - name: trusted-container
    image: busybox
    command: ["/bin/sh", "-c"]
    args: ["echo 'Access denied'"]
    securityContext:
      allowPrivilegeEscalation: false
```

Код, соответствующий требованиям, определяет стручок с именем "secure-pod" с единственным контейнером, основанным на образе "busybox". Контейнер выполняет команду, которая просто выдает эхо "Access denied", чтобы указать на ограниченный доступ. Секция securityContext добавляется с полем "allowPrivilegeEscalation", установленным в false, что предотвращает попытки повышения привилегий внутри контейнера.



## Повышение привилегий с помощью разрешений узла/прокси

Повышение привилегий через разрешения узлов/прокси - это техника в Kubernetes, использующая API-прокси узлов для повышения привилегий. Используя эту технику, злоумышленник с правами nodes/proxy может обойти проверки контроля допуска и логирование сервера API, чтобы повысить свои привилегии до администратора кластера.

Несоответствующий код:
Следующий код, не соответствующий требованиям, демонстрирует создание роли кластера с правами nodes/proxy и привязку ее к учетной записи службы:

```
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: nodes-proxy-role
rules:
- apiGroups: [""]
  resources: ["nodes/proxy"]
  verbs: ["*"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: nodes-proxy-binding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: nodes-proxy-role
subjects:
- kind: ServiceAccount
  name: nodes-proxy-sa
  namespace: your-namespace
```

Несоответствующий код создает кластерную роль с именем "nodes-proxy-role" с правилами, предоставляющими полный доступ к ресурсу nodes/proxy. Он также создает привязку кластерной роли с именем "nodes-proxy-binding", которая связывает роль с учетной записью службы с именем "nodes-proxy-sa" в определенном пространстве имен.



Соответствующий код:
Чтобы предотвратить повышение привилегий через разрешения узлов/прокси, очень важно реализовать принцип наименьших привилегий и ограничить доступ к важным ресурсам. Вот пример совместимого кода:

```
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: restricted-nodes-proxy-role
rules:
- apiGroups: [""]
  resources: ["nodes/proxy"]
  verbs: ["get"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: restricted-nodes-proxy-binding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: restricted-nodes-proxy-role
subjects:
- kind: ServiceAccount
  name: restricted-nodes-proxy-sa
  namespace: your-namespace
```

Соответствующий код создает роль кластера с именем "restricted-nodes-proxy-role" с правилом, которое разрешает только глагол "get" для ресурса nodes/proxy. Это значительно ограничивает разрешения, связанные с ролью, снижая риск повышения привилегий.



## Запуск привилегированной капсулы

Запуск привилегированного стручка в Kubernetes означает запуск стручка с повышенными привилегиями, что эквивалентно запуску от имени root на рабочем узле. Привилегированные стручки могут использоваться в качестве вектора повышения привилегий в кластере.

Несоответствующий код:
Следующий код, не соответствующий требованиям, демонстрирует создание привилегированной капсулы:

```
apiVersion: v1
kind: Pod
metadata:
  name: privileged-pod
  namespace: your-namespace
spec:
  containers:
  - name: privileged-container
    image: busybox:latest
    command: ["sleep", "3600"]
    securityContext:
      privileged: true
```

Несоответствующий код создает подкапсулу с именем "privileged-pod" в определенном пространстве имен. Он содержит один контейнер с именем "privileged-container", в котором запущен образ "busybox:latest". Поле securityContext.privileged установлено в true, что указывает на то, что pod должен работать с повышенными привилегиями.


Соответствующий код:
Чтобы обеспечить безопасность и целостность кластера, важно следовать принципу наименьших привилегий и по возможности избегать запуска привилегированных подсистем. Вот пример совместимого кода:

```
apiVersion: v1
kind: Pod
metadata:
  name: non-privileged-pod
  namespace: your-namespace
spec:
  containers:
  - name: non-privileged-container
    image: busybox:latest
    command: ["sleep", "3600"]
```

Соответствующий код создает капсулу с именем "non-privileged-pod" в определенном пространстве имен. Он содержит один контейнер с именем "non-privileged-container", в котором запущен образ "busybox:latest".

Если опустить поле securityContext.privileged или задать ему значение false (по умолчанию), pod и его контейнер будут работать с обычными привилегиями пользователя. Это снижает риск повышения привилегий и помогает поддерживать границы безопасности в кластере.

